# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\main.asm
  1   0000                  DEVICE ZXSPECTRUM48 ;Especificacion para el emulador           ;
  2   0000                  ORG $8000 ;Programa empieza en $8000                           ;
  3   8000 31 00 00         LD SP, 0 ;Carga del stack en 0                                 ;
  4   8003              ;-------------------------------------------------------------------
  5   8003              gameStart:
  6   8003 CD 7F 83         CALL STARTSCREEN ;Se llama a la pantalla de inicio
  7   8006              gameInit:
  8   8006 CD 71 80         CALL MAINGAME ;Se llama al juego
  9   8009              gameEnd:
 10   8009 CD 12 80         CALL ENDSCREEN ;Se llama a la pantalla final
 11   800C FE 68            CP 104 ;Se comprueba si se quiere jugar de nuevo
 12   800E 20 F3            JR NZ , gameStart
 13   8010
 14   8010 18 FE        mainEnd: JR mainEnd ;Se queda en un bucle infinito
 15   8012              ;-------------------------------------------------------------------
 16   8012                  INCLUDE pantalla-final.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-final.asm
  1+  8012              ENDSCREEN:
  2+  8012 CD 93 84         CALL CLEARSCR
  3+  8015              ;--------------------------------------------------
  4+  8015              ;Imprime el GAME OVER
  5+  8015 3E 82            LD A,2+$80 ; Se da formato de color al texto
  6+  8017 06 0A            LD B,10    ; Coordenada de la fila
  7+  8019 0E 0C            LD C,12     ; Coordenada de la columna
  8+  801B DD 21 51 80      LD IX, GameOverText   ; Se añade el título
  9+  801F CD 22 84         CALL PRINTAT
 10+  8022
 11+  8022 3E 03            LD A,3 ; Se da formato de color al texto
 12+  8024 06 0E            LD B, 14    ; Coordenada de la fila
 13+  8026 0E 04            LD C,4    ; Coordenada de la columna
 14+  8028 DD 21 5B 80      LD IX, ContinueText   ; Se añade el título
 15+  802C CD 22 84         CALL PRINTAT
 16+  802F CD 32 80         CALL TecladoFinal   ; Se lee el input del teclado hasta que se pulse S o N
 17+  8032
 18+  8032              ;Rutina que guarda lo que pulsa el usuario
 19+  8032              TecladoFinal:          ; Rutina para leer del teclado 'S' o 'N'
 20+  8032 01 FE 7F         LD BC,$7FFE         ; Escanear línea B,N,M,SYMB,Space
 21+  8035 ED 78            IN A,(C)
 22+  8037 CB 5F            BIT 3,A
 23+  8039 28 0E            JR Z,T_N_Final            ; Han pulsado N
 24+  803B 01 FE FD         LD BC,$FDFE         ; Escanear línea G,F,D,S,A
 25+  803E ED 78            IN A,(C)
 26+  8040 CB 4F            BIT 1,A
 27+  8042 20 EE            JR NZ,TecladoFinal       ; No han pulsado 'S'
 28+  8044
 29+  8044              T_S_final:
 30+  8044 18 04            JR Soltar_Tecla_Final     ; Esperar q que suelten la tecla
 31+  8046 3E 68            LD A, 104          ; Se guarda el valor 104 en A para nueva partida
 32+  8048 C9               RET
 33+  8049
 34+  8049              T_N_Final:
 35+  8049 C9               RET
 36+  804A
 37+  804A              Soltar_Tecla_Final:           ; Rutina de espera hasta que se suelta la tecla
 38+  804A ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 39+  804C FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 40+  804E 20 FA            JR NZ,Soltar_Tecla_Final  ; esperar hasta que no haya tecla pulsada
 41+  8050 C9               RET
 42+  8051
 43+  8051
 44+  8051
 45+  8051
 46+  8051              ;---------------------------------------------------------
 47+  8051 47 41 4D 45  GameOverText: db "GAME OVER", 0 ; Texto de fin de partida
 47+  8055 20 4F 56 45
 47+  8059 52 00
 48+  805B 44 65 73 65  ContinueText: db "Desea jugar de nuevo?", 0 ; Pregunta continue
 48+  805F 61 20 6A 75
 48+  8063 67 61 72 20
 48+  8067 64 65 20 6E
 48+  806B 75 65 76 6F
 48+  806F 3F 00
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-final.asm
 17   8071                  INCLUDE game.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\game.asm
  1+  8071              MAINGAME:                                 ;
  2+  8071 CD 93 84         CALL CLEARSCR  ;Limpia la pantalla    ;
  3+  8074              ;------------------------------------------
  4+  8074 CD 89 80         CALL CREATEBOARD ; Crea el tablero
  5+  8077              gameflow:
  6+  8077 CD 16 82         CALL RANDOMTETRO ; Geneta un tetromino aleatorio
  7+  807A 3E 0E            LD A, 14
  8+  807C 32 53 82         LD (Middle), A
  9+  807F CD 33 81         CALL TETRODOWN ; Llama a la funcion que dibuja y mueve el tetromino hacia abajo
 10+  8082 FE FE            CP 254 ;Comprueba el gaemover
 11+  8084 20 F1            JR NZ, gameflow ;Si no es gameover, sigue el juego
 12+  8086 C9               RET ; Si es gameover, sale del juego
 13+  8087
 14+  8087 18 FE        fin: JR fin
 15+  8089              ;-----------------------------------------
 16+  8089                  INCLUDE create-board.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\create-board.asm
  1++ 8089              CREATEBOARD:                                 ;
  2++ 8089 CD 93 84         CALL CLEARSCR                         ;
  3++ 808C              ANCHO EQU 14                              ;
  4++ 808C              LARGO EQU 22                              ;
  5++ 808C              ;------------------------------------------
  6++ 808C CD A9 88         CALL Tetris_3D
  7++ 808F 3E 20            LD A, 32 ; Se carga en A el ancho de la pantalla
  8++ 8091 D6 02            SUB 2 ;Se le resta 2, que serán las columnas de los bordes
  9++ 8093 D6 0E            SUB ANCHO ;Se le resta el ancho del tablero
 10++ 8095 CB 3F            SRL A ;Se divide
 11++ 8097 4F               LD C, A
 12++ 8098 3E 00            LD A, 0
 13++ 809A C6 1F            ADD (32 - 1)
 14++ 809C 47               LD B, A
 15++ 809D 21 00 58         LD HL, $5800 ; Se guarda la dirección de memoria donde se guardan los atributos de la pantalla
 16++ 80A0              bucle1:
 17++ 80A0 23               INC HL ; Se incrementa la dirección de memoria
 18++ 80A1 10 FD            DJNZ bucle1 ; Se repite hasta que completa toda la fila vacía
 19++ 80A3 06 16            LD B, LARGO
 20++ 80A5              bucle:
 21++ 80A5 C5               PUSH BC
 22++ 80A6 41               LD B, C
 23++ 80A7              marco_izq: ;Se deja espacio para el marco izquierdo
 24++ 80A7 23               INC HL
 25++ 80A8 10 FD            DJNZ marco_izq
 26++ 80AA C5               PUSH BC
 27++ 80AB              margenizq: ;Se pinta todo el borde izquierdo de blanco
 28++ 80AB 23               INC HL
 29++ 80AC 0E 07            LD C, 7
 30++ 80AE 79               LD A, C
 31++ 80AF 87               ADD A
 32++ 80B0 87               ADD A
 33++ 80B1 87               ADD A
 34++ 80B2 77               LD (HL), A
 35++ 80B3 3E 00            LD A, 0
 36++ 80B5 06 0E            LD B, ANCHO
 37++ 80B7 80               ADD B
 38++ 80B8 47               LD B, A
 39++ 80B9              comienzo_ancho:
 40++ 80B9 23               INC HL
 41++ 80BA 10 FD            DJNZ comienzo_ancho ;Se deja el ancho del tablero sin pintar
 42++ 80BC              margendrcho: ;Se pinta el borde derecho
 43++ 80BC 23               INC HL
 44++ 80BD 0E 07            LD C,7
 45++ 80BF 79               LD A, C
 46++ 80C0 87               ADD A
 47++ 80C1 87               ADD A
 48++ 80C2 87               ADD A
 49++ 80C3 77               ld (HL), A
 50++ 80C4
 51++ 80C4 C1               POP BC
 52++ 80C5 41               LD B, C
 53++ 80C6              marco_drcho: ;Se deja espacio después del marco derecho
 54++ 80C6 23               INC HL
 55++ 80C7 10 FD            DJNZ marco_drcho
 56++ 80C9 C1               POP BC
 57++ 80CA 10 D9            DJNZ bucle
 58++ 80CC
 59++ 80CC 41               LD B, C
 60++ 80CD              marco_izq_fila_ult:;Se deja espacio para el marco izquierdo de la última fila
 61++ 80CD 23               INC HL
 62++ 80CE 10 FD            DJNZ marco_izq_fila_ult
 63++ 80D0              fila_ultima: ;Se reserva el espacio de la última fila
 64++ 80D0 06 10            LD B, ANCHO + 2
 65++ 80D2              bucle2: ;Se pinta la última fila de blanco
 66++ 80D2 23               INC HL
 67++ 80D3 0E 07            LD C,7
 68++ 80D5 79               LD A, C
 69++ 80D6 87               ADD A
 70++ 80D7 87               ADD A
 71++ 80D8 87               ADD A
 72++ 80D9 77               ld (HL), A
 73++ 80DA 10 F6            DJNZ bucle2
 74++ 80DC
 75++ 80DC C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\create-board.asm
 17+  80DD                  INCLUDE draw-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-tetro.asm
  1++ 80DD              DRAWTETRO:
  2++ 80DD              ;---------------------------------------------
  3++ 80DD DD 7E 00         LD A, (IX)  ; Se carga el valor de la pieza
  4++ 80E0 57               LD D, A ; Se guarda en D
  5++ 80E1 DD 23            INC IX
  6++ 80E3 3A 4D 82         LD A, (IXCounter)
  7++ 80E6 3C               INC A
  8++ 80E7 32 4D 82         LD (IXCounter), A
  9++ 80EA DD 7E 00         LD A, (IX)
 10++ 80ED 5F               LD E, A
 11++ 80EE 42               LD B, D
 12++ 80EF              drawfilas:
 13++ 80EF C5               PUSH BC ; Se guarda el valor de B
 14++ 80F0 43               LD B, E ; Se carga el número de columnas
 15++ 80F1              drawcolumnas:
 16++ 80F1 50               LD D, B ; Se carga el número de columnas
 17++ 80F2 DD 23            INC IX
 18++ 80F4 3A 4D 82         LD A, (IXCounter)
 19++ 80F7 3C               INC A
 20++ 80F8 32 4D 82         LD (IXCounter), A
 21++ 80FB DD 7E 00         LD A, (IX)
 22++ 80FE C1               POP BC ; Se recupera el valor de B
 23++ 80FF 4A               LD C, D ; Se carga la posición del pixel a dibujar
 24++ 8100 CD 0B 81         CALL DRAWPIXEL ; Se dibuja el pixel
 25++ 8103 C5               PUSH BC
 26++ 8104 42               LD B, D ;Se decrementa el número de columnas restantes
 27++ 8105 10 EA            DJNZ drawcolumnas ;Comprueba que se hayan pintado todas las columnas
 28++ 8107 C1               POP BC ; Se recupera el valor de B
 29++ 8108 10 E5            DJNZ drawfilas ;Comprueba que se hayan pintado todas las filas
 30++ 810A
 31++ 810A C9               RET
 32++ 810B              ;------------------------------------------
 33++ 810B                  INCLUDE draw-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-pixel.asm
  1+++810B              DRAWPIXEL:
  2+++810B F5               PUSH AF
  3+++810C D5               PUSH DE ;Se guardan todos los registros
  4+++810D F5               PUSH AF
  5+++810E C5               PUSH BC
  6+++810F              ;------------------------------------------------------
  7+++810F 78               LD A, B ;Se carga la posicion en A
  8+++8110 FD 86 00         ADD (IY) ;Se suma la posicion con la posicion del tetro
  9+++8113 47               LD B, A ; Se carga la posición actualizada en B
 10+++8114 68               LD L, B
 11+++8115 26 00            LD H, 0 ; HL = B
 12+++8117
 13+++8117 29               ADD HL, HL
 14+++8118 29               ADD HL, HL
 15+++8119 29               ADD HL, HL
 16+++811A 29               ADD HL, HL
 17+++811B 29               ADD HL, HL; HL = HL *32
 18+++811C 3A 53 82         LD A, (Middle) ;Se carga la posición del tetro en el eje X
 19+++811F 81               ADD C  ;
 20+++8120 4F               LD C, A
 21+++8121 59               LD E, C
 22+++8122 16 00            LD D, 0 ; DE = C
 23+++8124 19               ADD HL, DE ;Se cargan los atributos
 24+++8125 11 00 58         LD DE, $5800
 25+++8128 19               ADD HL, DE ; HL = Y*32 + X + $5800
 26+++8129 C1               POP BC
 27+++812A F1               POP AF
 28+++812B FE 00            CP 0
 29+++812D 28 01            JR Z, tetroExistDraw ;Si el valor es 0, no se dibuja
 30+++812F 77               LD (HL), A
 31+++8130              tetroExistDraw:
 32+++8130 D1               POP DE
 33+++8131 F1               POP AF
 34+++8132 C9               RET
 35+++8133              ;------------------------------------------------
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-tetro.asm
 18+  8133                  INCLUDE tetro-down.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-down.asm
  1++ 8133              TETRODOWN:
  2++ 8133              ;-----------------------------------------
  3++ 8133 FD 21 8A 88      LD IY, row_coords ;Se carga la direccion de memoria de la fila
  4++ 8137 CD 55 82         CALL CHECKCOLISION ;Se llama a la funcion que revisa si hay colision
  5++ 813A FE 64            CP 100 ;Se comprueba la condición de derrota
  6++ 813C 28 6E            JR Z, goGameOver ;Si se va a la funcion de GameOver
  7++ 813E CD 08 82         CALL LASTPOSITION ;Si no, se llama a la funcion que devuelve IX
  8++ 8141
  9++ 8141              down:
 10++ 8141 C5               PUSH BC ;Se guarda el valor de BC
 11++ 8142 CD DD 80         CALL DRAWTETRO ;Se llama a la funcion que dibuja el tetromino
 12++ 8145 CD 08 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 13++ 8148 CD 3C 82         CALL TETRODELAY ;Se llama a la funcion que hace el tiempo de espera
 14++ 814B CD B1 81         CALL TETRODEL ;Se llama a la funcion que borra el tetromino
 15++ 814E CD 08 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 16++ 8151 FD 23            INC IY ;Se incrementa la fila
 17++ 8153 CD F5 82         CALL TETROMOVE ;Se llama a la funcion que comprueba el movimiento del tetromino
 18++ 8156 CD C6 82         CALL TURNTETRO ;Se llama a la funcion que comprueba el giro el tetromino
 19++ 8159 CD 55 82         CALL CHECKCOLISION ;Se llama a la funcion que comprueba si hay colision
 20++ 815C FE 64            CP 100 ;Se comprueban las colisiones
 21++ 815E 28 0B            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 22++ 8160 20 00            JR NZ, downcontinue ;Si no, se continua bajando
 23++ 8162
 24++ 8162              downcontinue:
 25++ 8162 CD 27 83         CALL DELROW ;Se llama a la funcion que comprueba si hay fila completa
 26++ 8165 CD 08 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 27++ 8168 C1               POP BC ;Se recupera el valor de BC
 28++ 8169 18 D6            JR down ;Continua la función de bajar pieza
 29++ 816B              nexttetro:
 30++ 816B CD 08 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 31++ 816E 3A 53 82         LD A, (Middle) ;Se carga el valor de la variable Middle, que contiene la posición del tetro respecto al centro
 32++ 8171 FE 07            CP 7
 33++ 8173 28 28            JR Z, left_wall
 34++ 8175 FE 08            CP 8
 35++ 8177 28 24            JR Z, left_wall ;Se comprueban las colisiones con las paredes izquierda y derecha
 36++ 8179 FE 14            CP 20
 37++ 817B 28 11            JR Z, right_wall
 38++ 817D FE 15            CP 21
 39++ 817F 28 0D            JR Z, right_wall
 40++ 8181 C1               POP BC ;Se recupera el valor de BC
 41++ 8182 FD 2B            DEC IY ;Se decrementa la fila
 42++ 8184 CD DD 80         CALL DRAWTETRO ;Se llama a la funcion que dibuja el tetromino
 43++ 8187 CD 08 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 44++ 818A CD 30 82         CALL RETURNIY ;Se llama a la funcion que devuelve IY
 45++ 818D C9               RET ;Se sale de la rutina hacia el main (Tetro posicionado)
 46++ 818E              right_wall:
 47++ 818E 3D               DEC A ;Si se colisiona con la pared derecha, mueve el tetro hacia la izquierda
 48++ 818F 32 53 82         LD (Middle), A ;Realiza el cambio de posición
 49++ 8192 CD 55 82         CALL CHECKCOLISION ;Se comprueba si hay colisisión
 50++ 8195 FE 64            CP 100
 51++ 8197 28 D2            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 52++ 8199 20 C7            JR NZ, downcontinue ;Si no, se continua bajando
 53++ 819B 18 A4            JR down
 54++ 819D              left_wall:
 55++ 819D 3C               INC A ;Si se colisiona con la pared izquierda, mueve el tetro hacia la derecha
 56++ 819E 32 53 82         LD (Middle), A ;Realiza el cambio de posición
 57++ 81A1 CD 55 82         CALL CHECKCOLISION ;Se comprueba si hay colisisión
 58++ 81A4 FE 64            CP 100
 59++ 81A6 28 C3            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 60++ 81A8 20 B8            JR NZ, downcontinue ;Si no, se continua bajando
 61++ 81AA
 62++ 81AA 18 95            JR down
 63++ 81AC              goGameOver:
 64++ 81AC C1               POP BC ;Se recupera el valor de BC
 65++ 81AD 3E FE            LD A, 254 ;Se carga el valor de 254 en A para comprobar la derrota
 66++ 81AF C9               RET ;Vueleve al main
 67++ 81B0              gamecontinue:
 68++ 81B0 C9               RET
 69++ 81B1              ;----------------------------------------------------
 70++ 81B1                  INCLUDE del-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-tetro.asm
  1+++81B1              TETRODEL:
  2+++81B1              ;------------------------------------------------------
  3+++81B1 DD 7E 00         LD A, (IX) ; Se carga en A el tetrominó actual
  4+++81B4 57               LD D, A ; Se guarda en D el tetrominó actual
  5+++81B5 DD 23            INC IX
  6+++81B7 3A 4D 82         LD A, (IXCounter)
  7+++81BA 3C               INC A
  8+++81BB 32 4D 82         LD (IXCounter), A
  9+++81BE DD 7E 00         LD A, (IX)
 10+++81C1 5F               LD E, A ;Se guardan las columnas en E
 11+++81C2 42               LD B, D ;Se guardan las filas en B
 12+++81C3              rowdel:
 13+++81C3 C5               PUSH BC ;Se guarda en la pila el valor de B
 14+++81C4 43               LD B, E ;Se cargan las columnas en B
 15+++81C5              columndel:
 16+++81C5 50               LD D, B
 17+++81C6 DD 23            INC IX ;Se incrementa IX para que apunte a la siguiente posición
 18+++81C8 3A 4D 82         LD A, (IXCounter)
 19+++81CB 3C               INC A
 20+++81CC 32 4D 82         LD (IXCounter), A
 21+++81CF DD 7E 00         LD A, (IX)
 22+++81D2 C1               POP BC
 23+++81D3 4A               LD C, D ;Se carga la posición del pixel a borrar en C
 24+++81D4 CD DF 81         CALL DELPIXEL ;Se borra el pixel en las coordenadas indicadas
 25+++81D7 C5               PUSH BC
 26+++81D8 42               LD B, D
 27+++81D9 10 EA            DJNZ columndel ;Se repite el bucle hasta que se borren todas las columnas
 28+++81DB C1               POP BC ;Se recupera el valor de B
 29+++81DC 10 E5            DJNZ rowdel ;Se repite el bucle hasta que se borren todas las filas
 30+++81DE
 31+++81DE C9               RET
 32+++81DF              ;-----------------------------------------
 33+++81DF                  INCLUDE del-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-pixel.asm
  1+++81DF              DELPIXEL:
  2+++81DF              ;--------------------------------------------------
  3+++81DF F5               PUSH AF
  4+++81E0 D5               PUSH DE
  5+++81E1 F5               PUSH AF
  6+++81E2 C5               PUSH BC
  7+++81E3
  8+++81E3 78               LD A, B ; Se carga la posición en A
  9+++81E4 FD 86 00         ADD (IY) ; Se suma la fila
 10+++81E7 47               LD B, A ; Se guarda la posición en B
 11+++81E8 68               LD L, B
 12+++81E9 26 00            LD H, 0 ; HL = B
 13+++81EB
 14+++81EB 29               ADD HL, HL
 15+++81EC 29               ADD HL, HL
 16+++81ED 29               ADD HL, HL
 17+++81EE 29               ADD HL, HL
 18+++81EF 29               ADD HL, HL; HL = HL *32
 19+++81F0 3A 53 82         LD A, (Middle) ; Se carga la posición en A
 20+++81F3 81               ADD C
 21+++81F4 4F               LD C, A
 22+++81F5 59               LD E, C
 23+++81F6 16 00            LD D, 0 ; DE = C
 24+++81F8 19               ADD HL, DE ;Se cargan los atributos del tetro
 25+++81F9 11 00 58         LD DE, $5800
 26+++81FC 19               ADD HL, DE ; HL = Y*32 + X + $5800
 27+++81FD C1               POP BC
 28+++81FE F1               POP AF
 29+++81FF FE 00            CP 0
 30+++8201 28 02            JR Z, tetroExist ;Si el valor es 0, no se borrará nada
 31+++8203 36 00            LD (HL), 0
 32+++8205              tetroExist:
 33+++8205 D1               POP DE
 34+++8206 F1               POP AF
 35+++8207 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-tetro.asm
 71++ 8208                  INCLUDE last-position.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\last-position.asm
  1+++8208              LASTPOSITION:
  2+++8208              ;---------------------------
  3+++8208 3A 4D 82         LD A, (IXCounter) ;Se carga en A el valor de IXCounter
  4+++820B 47               LD B, A
  5+++820C              return:
  6+++820C DD 2B            DEC IX
  7+++820E 10 FC            DJNZ return
  8+++8210
  9+++8210 3E 00            LD A, 0
 10+++8212 32 4D 82         LD (IXCounter), A
 11+++8215 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\last-position.asm
 72++ 8216                  INCLUDE tetro-random.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-random.asm
  1+++8216              RANDOMTETRO:
  2+++8216 ED 5F            LD A, R ;Se carga en A un número aleatorio entre 0 y 255
  3+++8218 E6 1F            AND 31 ;Se hace un AND con 31 para que el número esté entre 0 y 31
  4+++821A FE 13            CP 19 ;Se compara con 19, si es menor
  5+++821C 38 02            JR C, continue ;Si es menor que 19, se carga el tetrominó
  6+++821E D6 13            SUB 19 ;Si es mayor, se le resta 19
  7+++8220              continue:
  8+++8220 DD 21 A6 87      LD IX, T_O ;Se carga el tetrominó O
  9+++8224 11 0C 00         LD DE, ANCHOTETRO ;Se guarda el ancho de palabra del tetrominó
 10+++8227 B7               OR A ;Si es 0, se termina la rutina y se pinta el tetrominó O
 11+++8228 28 05            JR Z, randomend
 12+++822A              more:
 13+++822A DD 19            ADD IX, DE ;Si no lo es, se pasa al siguiente tetrominó
 14+++822C 3D               DEC A
 15+++822D 20 FB            JR NZ, more ;Se repite hasta que se llegue a la dirección de memoria del tretrominó a pintar
 16+++822F
 17+++822F              randomend:
 18+++822F C9               RET
 19+++8230              ;-------------------------------
 20+++8230              ANCHOTETRO EQU T_L1 - T_O
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-random.asm
 73++ 8230                  INCLUDE IYReturn.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\IYReturn.asm
  1+++8230              RETURNIY:
  2+++8230              ;----------------------------
  3+++8230 FD 7E 00         LD A, (IY) ; Se guarda en A la direccuón de memoria a la que apunta IY
  4+++8233 FE 00            CP 0 ; Se compara con 0
  5+++8235 28 04            JR Z, final ; Si es 0, se sale del programa
  6+++8237 FD 2B            DEC IY ; Si no, se decrementa IY
  7+++8239 18 F5            JR RETURNIY ;Hasta que sea 0
  8+++823B
  9+++823B
 10+++823B              final:
 11+++823B C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\IYReturn.asm
 74++ 823C                  INCLUDE delay-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\delay-tetro.asm
  1+++823C              TETRODELAY:
  2+++823C              ;------------------------------------------
  3+++823C 21 88 13         LD HL, 5000 ; Se impone un tiempo de espera entre movimiento y movimiento
  4+++823F              delayloop:
  5+++823F 2B               DEC HL
  6+++8240 7C               LD A, H
  7+++8241 F6 00            OR 0 ;Se va decerementando el registro HL hasta que sea 0
  8+++8243 20 FA            JR NZ, delayloop
  9+++8245 C9               RET ;Cuando pase el tiempo, se sigue el programa
 10+++8246
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\delay-tetro.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-down.asm
 19+  8246                  INCLUDE position-coords.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\position-coords.asm
  1++ 8246              gamestatusstruct:
  2++ 8246              ;--------------------
  3++ 8246
  4++ 8246 00           GameX: DB 0
  5++ 8247 00           GameY: DB 0
  6++ 8248 00 00        TetroPtr: DW 0
  7++ 824A 00 00        DownCounter: DW 0
  8++ 824C 00           UndoKey: DB 0
  9++ 824D 00           IXCounter: DB 0
 10++ 824E 00           PosibleColor: DB 0
 11++ 824F 00           NewColor: DB 0
 12++ 8250 00           OldColor: DB 0
 13++ 8251 00           GameXPosible: DB 0
 14++ 8252 00           GameYPosible: DB 0
 15++ 8253 0E           Middle: DB 14
 16++ 8254 00           FilaCompleta: DB 0
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\position-coords.asm
 20+  8255                  INCLUDE check-colision.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-colision.asm
  1++ 8255              CHECKCOLISION:
  2++ 8255              ;--------------------------------------------
  3++ 8255 DD 7E 00         LD A, (IX)
  4++ 8258 57               LD D, A
  5++ 8259 DD 23            INC IX
  6++ 825B 3A 4D 82         LD A, (IXCounter)
  7++ 825E 3C               INC A
  8++ 825F 32 4D 82         LD (IXCounter), A
  9++ 8262 DD 7E 00         LD A, (IX)
 10++ 8265 5F               LD E, A
 11++ 8266 42               LD B, D
 12++ 8267              fil:
 13++ 8267 C5               PUSH BC
 14++ 8268 43               LD B, E
 15++ 8269              cols:
 16++ 8269 50               LD D, B
 17++ 826A DD 23            INC IX
 18++ 826C 3A 4D 82         LD A, (IXCounter)
 19++ 826F 3C               INC A
 20++ 8270 32 4D 82         LD (IXCounter), A
 21++ 8273 DD 7E 00         LD A, (IX)
 22++ 8276 32 4F 82         LD (NewColor), A ;Guardamos el color del pixel que queremos pintar en ColorNuevo
 23++ 8279 C1               POP BC
 24++ 827A 4A               LD C, D
 25++ 827B CD A4 82         CALL comprobarpunto ;A=color, B=fila, C=columna
 26++ 827E 32 50 82         LD (OldColor), A ;comprobarpunto nos devuelve el color que había antes de pintar el pixel nuevo, por lo que lo almacenamos en ColorViejo
 27++ 8281 78               LD A, B
 28++ 8282 32 51 82         LD (GameXPosible), A
 29++ 8285 79               LD A, C
 30++ 8286 32 52 82         LD (GameYPosible), A
 31++ 8289 3A 50 82         LD A, (OldColor)
 32++ 828C FE 00            CP 0 ;Si dicho ColorViejo es negro, se podrá continuar comprobando los demás pixeles.
 33++ 828E 28 0C            JR Z, no_hay_color ;Si encontramos un color viejo existente, saltamos a ver los casos posibles
 34++ 8290              puede_haber_color:
 35++ 8290 3A 4F 82         LD A, (NewColor)
 36++ 8293 FE 00            CP 0  ;En el caso de que haya color viejo, tenemos que observar si el color del pixel
 37++ 8295 20 02            JR NZ, hay_color ;nuevo es negro o no, ya que en dicho caso no colisionarían colores.
 38++ 8297 28 03            JR Z, no_hay_color
 39++ 8299              hay_color: ;Si existe un color viejo y nuevo, colisiona, por lo que habrá que ver si se trata de una pared o no.
 40++ 8299 3E 64            LD A, 100
 41++ 829B C9               RET
 42++ 829C              no_hay_color: ;En caso de no haber un color, comprueba otro pixel
 43++ 829C C5               PUSH BC
 44++ 829D 42               LD B, D
 45++ 829E 10 C9            DJNZ cols ;Comprueba todas las columnas
 46++ 82A0 C1               POP BC
 47++ 82A1 10 C4            DJNZ fil ;Comprueba todas las filas
 48++ 82A3
 49++ 82A3 C9               RET
 50++ 82A4              ;----------------------------------------
 51++ 82A4                  INCLUDE check-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-pixel.asm
  1+++82A4              comprobarpunto:
  2+++82A4              ;-------------------------------------------------------
  3+++82A4 D5               PUSH DE
  4+++82A5 F5               PUSH AF
  5+++82A6 C5               PUSH BC
  6+++82A7
  7+++82A7 68               LD L, B
  8+++82A8 FD 7E 00         LD A, (IY)
  9+++82AB 85               ADD L
 10+++82AC 6F               LD L, A
 11+++82AD 26 00            LD H, 0 ; HL = B
 12+++82AF 29               ADD HL, HL
 13+++82B0 29               ADD HL, HL
 14+++82B1 29               ADD HL, HL
 15+++82B2 29               ADD HL, HL
 16+++82B3 29               ADD HL, HL; HL = HL *32
 17+++82B4 3A 53 82         LD A, (Middle) ;Guarda en A la posición del tetro respecto al centro
 18+++82B7 81               ADD C
 19+++82B8 4F               LD C, A
 20+++82B9 59               LD E, C
 21+++82BA 16 00            LD D, 0 ; DE = C
 22+++82BC 19               ADD HL, DE
 23+++82BD 11 00 58         LD DE, $5800
 24+++82C0 19               ADD HL, DE ; HL = Y*32 + X + $5800
 25+++82C1 C1               POP BC
 26+++82C2 F1               POP AF
 27+++82C3 D1               POP DE
 28+++82C4 7E               LD A, (HL)
 29+++82C5 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-colision.asm
 21+  82C6                  INCLUDE turn-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\turn-tetro.asm
  1++ 82C6              TURNTETRO:
  2++ 82C6              ;--------------------------------------------------------------------
  3++ 82C6
  4++ 82C6 01 FE FB         LD BC,$FBFE        ; Escanear línea  T,R,E,W,Q
  5++ 82C9 ED 78            IN A,(C)
  6++ 82CB CB 47            BIT 0,A
  7++ 82CD 28 12            JR Z, turn_left    ; Han pulsado Q -> Girar izquierda
  8++ 82CF CB 4F            BIT 1,A
  9++ 82D1 28 02            JR Z, turn_right  ; Han pulsado W -> Girar derecha
 10++ 82D3 18 1F            JR no_tecla         ; No hay tecla pulsada
 11++ 82D5
 12++ 82D5              turn_right:
 13++ 82D5 DD 6E 0A         LD L, (IX + 10)
 14++ 82D8 DD 66 0B         LD H, (IX + 11)
 15++ 82DB E5 DD E1         LD IX, HL
 16++ 82DE 18 0D            JR SoltarTecla     ; Esperar que suelten la tecla
 17++ 82E0 C9               RET
 18++ 82E1
 19++ 82E1              turn_left:
 20++ 82E1 DD 6E 08         LD L, (IX + 8)
 21++ 82E4 DD 66 09         LD H, (IX + 9)
 22++ 82E7 E5 DD E1         LD IX, HL
 23++ 82EA 18 01            JR SoltarTecla     ; Esperar que suelten la tecla
 24++ 82EC C9               RET
 25++ 82ED
 26++ 82ED
 27++ 82ED              SoltarTecla:           ; Rutina de espera hasta que se suelta la tecla
 28++ 82ED ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 29++ 82EF FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 30++ 82F1 20 FA            JR NZ,SoltarTecla  ; esperar hasta que no haya tecla pulsada
 31++ 82F3 C9               RET
 32++ 82F4
 33++ 82F4              no_tecla:
 34++ 82F4 C9               RET
 35++ 82F5
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\turn-tetro.asm
 22+  82F5                  INCLUDE tetro-move.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-move.asm
  1++ 82F5              TETROMOVE:
  2++ 82F5              ;----------------------------------------
  3++ 82F5
  4++ 82F5 01 FE BF         LD BC,$BFFE       ; Escanear línea  H,J,K,L,ENTER
  5++ 82F8 ED 78            IN A,(C)
  6++ 82FA CB 5F            BIT 3,A
  7++ 82FC 28 14            JR Z, move_left    ; Han pulsado J -> Mover izquierda
  8++ 82FE CB 57            BIT 2,A
  9++ 8300 28 06            JR Z, move_right  ; Han pulsado K -> Mover derecha
 10++ 8302 CB 47            BIT 0,A
 11++ 8304 28 16            JR Z, move_down ; Han pulsado ENTER -> Mover abajo
 12++ 8306 18 1E            JR no_tecla_move     ; No hay tecla pulsada
 13++ 8308
 14++ 8308              move_right:
 15++ 8308 3A 53 82         LD A, (Middle)
 16++ 830B 3C               INC A
 17++ 830C 32 53 82         LD (Middle), A
 18++ 830F 18 0E            JR SoltarTeclaMv     ; Esperar que suelten la tecla
 19++ 8311 C9               RET
 20++ 8312
 21++ 8312              move_left:
 22++ 8312 3A 53 82         LD A, (Middle)
 23++ 8315 3D               DEC A
 24++ 8316 32 53 82         LD (Middle), A
 25++ 8319 18 04            JR SoltarTeclaMv     ; Esperar que suelten la tecla
 26++ 831B C9               RET
 27++ 831C
 28++ 831C              move_down:
 29++ 831C FD 23            INC IY ;Se baja la fila
 30++ 831E C9               RET ;Se sale de la rutina
 31++ 831F
 32++ 831F              SoltarTeclaMv:           ; Rutina de espera hasta que se suelta la tecla
 33++ 831F ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 34++ 8321 FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 35++ 8323 20 FA            JR NZ,SoltarTeclaMv  ; esperar hasta que no haya tecla pulsada
 36++ 8325 C9               RET
 37++ 8326
 38++ 8326              no_tecla_move:
 39++ 8326 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-move.asm
 23+  8327                  INCLUDE del-row.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-row.asm
  1++ 8327              DELROW: ;Esta subrutina es igual que la del borde, solo que se comprueba si existe una fila en la que sea todo color.
  2++ 8327              ANCHOTAB EQU 14
  3++ 8327              LARGOTAB EQU 17
  4++ 8327              ;-----------------------------------------------------------------------------------------------------------------------------
  5++ 8327 3E 20            LD A, 32
  6++ 8329 D6 02            SUB 2
  7++ 832B D6 0E            SUB ANCHOTAB
  8++ 832D CB 3F            SRL A
  9++ 832F 4F               LD C, A
 10++ 8330 3E 00            LD A, 0
 11++ 8332 C6 9F            ADD (32 * 5 - 1)
 12++ 8334 47               LD B, A
 13++ 8335 21 00 58         LD HL, $5800
 14++ 8338              buc1:
 15++ 8338 23               INC HL
 16++ 8339 10 FD            DJNZ buc1
 17++ 833B 06 11            LD B, LARGOTAB
 18++ 833D              buc:
 19++ 833D C5               PUSH BC
 20++ 833E 41               LD B, C
 21++ 833F              marco_izquierdo:
 22++ 833F 23               INC HL
 23++ 8340 10 FD            DJNZ marco_izquierdo
 24++ 8342 C5               PUSH BC
 25++ 8343              margen__izq:
 26++ 8343 23               INC HL
 27++ 8344
 28++ 8344
 29++ 8344 06 0E            LD B, ANCHOTAB
 30++ 8346 3E 00            LD A, 0
 31++ 8348 32 54 82         LD (FilaCompleta), A ;FilaCompleta será un contador. Si el contador llega a ser igual que el ancho, significará que se ha encontrado una fila completa de color
 32++ 834B              comienzo__ancho:
 33++ 834B 23               INC HL
 34++ 834C 7E               LD A, (HL)
 35++ 834D FE 00            CP 0
 36++ 834F 20 07            JR NZ, color
 37++ 8351 28 00            JR Z, reinicio_color
 38++ 8353              reinicio_color:
 39++ 8353 3E 00            LD A, 0 ;Si no se detecta color, inicializamos FilaCompleta a 0, por lo que ya nunca llegará a valer lo que vale anchotab
 40++ 8355 32 54 82         LD (FilaCompleta), A
 41++ 8358              color:
 42++ 8358 3A 54 82         LD A, (FilaCompleta)
 43++ 835B 3C               INC A ;Si se detecta color, incrementamos FilaCompleta
 44++ 835C 32 54 82         LD (FilaCompleta), A
 45++ 835F 10 EA            DJNZ comienzo__ancho
 46++ 8361
 47++ 8361 3A 54 82         LD A, (FilaCompleta)
 48++ 8364 FE 0E            CP ANCHOTAB ;Comparamos con ANCHOTAB, lo que decidirá si se ha de borrar o no la fila
 49++ 8366 28 02            JR Z, borrarlafila
 50++ 8368 18 0B            JR cotinuerowdel
 51++ 836A              borrarlafila:
 52++ 836A 3E 00            LD A, 0
 53++ 836C 06 0E            LD B, ANCHOTAB
 54++ 836E 80               ADD B
 55++ 836F 47               LD B, A ;Creamos un bucle a la inversa, que decremente HL una fila y ponga a negro dicha fila pixel a pixel.
 56++ 8370              decrementarhl:
 57++ 8370 36 00            LD (HL), 0
 58++ 8372 2B               DEC HL
 59++ 8373 10 FB            DJNZ decrementarhl
 60++ 8375              cotinuerowdel:
 61++ 8375              margen__drcho:
 62++ 8375 23               INC HL
 63++ 8376
 64++ 8376 C1               POP BC
 65++ 8377 41               LD B, C
 66++ 8378              marco_derecho
 67++ 8378 23               INC HL
 68++ 8379 10 FD            DJNZ marco_derecho
 69++ 837B C1               POP BC
 70++ 837C 10 BF            DJNZ buc
 71++ 837E
 72++ 837E C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-row.asm
 24+  837F
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\game.asm
 18   837F                  INCLUDE pantalla-inicio.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-inicio.asm
  1+  837F
  2+  837F              STARTSCREEN:                                   ;
  3+  837F CD 93 84         CALL CLEARSCR                              ;
  4+  8382 CD 85 83         CALL startInit                             ;
  5+  8385              ;-----------------------------------------------
  6+  8385              startInit:
  7+  8385              ;Imprimir título
  8+  8385 3E 83            LD A,3+$80 ; Se da formato de color al texto
  9+  8387 06 03            LD B,3     ; Coordenada de la fila
 10+  8389 0E 08            LD C,8     ; Coordenada de la columna
 11+  838B DD 21 E4 83      LD IX,StartTitle    ; Se añade el título
 12+  838F CD 22 84         CALL PRINTAT    ; Se llama a la rutina que imprime el título
 13+  8392
 14+  8392              ;Imprimir pregunta
 15+  8392
 16+  8392 3E 04            LD A,4  ; Se da formato de color al texto
 17+  8394 06 0E            LD B,14 ; Coordenada de la fila
 18+  8396 0E 02            LD C,2  ; Coordenada de la columna
 19+  8398 DD 21 F6 83      LD IX,StartQuestion ; Se añade la pregunta
 20+  839C CD 22 84         CALL PRINTAT ; Se llama a la rutina para imprimir la pregunta
 21+  839F
 22+  839F 06 0E            LD B,14 ; Se pone el cursor en las coordenadas 14(fila)
 23+  83A1 0E 1C            LD C,28 ; y 28(Columna)
 24+  83A3 CD AC 83         CALL Coor_Atrib ; Llamamos a la rutina encargada de devolver la dirección del atributo
 25+  83A6 3E 84            LD A,4+$80  ; Se le da el formato
 26+  83A8 77               LD (HL),A   ; Se imprime el cursor
 27+  83A9
 28+  83A9 CD C7 83         CALL TecladoInicio    ; Se lee el input del teclado hasta que se pulse S o N
 29+  83AC
 30+  83AC
 31+  83AC              ;Función para guardar coordenadas
 32+  83AC              Coor_Atrib:
 33+  83AC F5               PUSH AF ; Se guarda el registro AF en el stack
 34+  83AD 60               LD H,b  ; Los bits 4,5 de B deben ser los bits 0,1 de H
 35+  83AE CB 3C            SRL H
 35+  83B0 CB 3C          SRL H
 35+  83B2 CB 3C          SRL H
 36+  83B4 78               LD A,B  ; Los bits 0,1,2 de B deben ser los bits 5,6,7 de L
 37+  83B5 CB 27            SLA A
 37+  83B7 CB 27          SLA A
 37+  83B9 CB 27          SLA A
 37+  83BB CB 27          SLA A
 37+  83BD CB 27          SLA a
 38+  83BF B1               OR c  ; Y C son los bits 0-4 de L
 39+  83C0 6F               LD L,A
 40+  83C1 01 00 58         LD BC, $5800
 41+  83C4 09               ADD HL,BC ; Se le suma la dirección de memoria del comienzo de los atributos
 42+  83C5 F1               POP AF ; Se devuelve el registro AF del stack
 43+  83C6 C9               RET
 44+  83C7
 45+  83C7              ;Rutina que guarda lo que pulsa el usuario
 46+  83C7              TecladoInicio:          ; Rutina para leer del teclado 'S' o 'N'
 47+  83C7 01 FE 7F         LD BC,$7FFE         ; Escanear línea B,N,M,SYMB,Space
 48+  83CA ED 78            IN A,(C)
 49+  83CC CB 5F            BIT 3,A
 50+  83CE 28 0C            JR Z,T_N            ; Han pulsado N
 51+  83D0 01 FE FD         LD BC,$FDFE         ; Escanear línea G,F,D,S,A
 52+  83D3 ED 78            IN A,(C)
 53+  83D5 CB 4F            BIT 1,A
 54+  83D7 20 EE            JR NZ,TecladoInicio       ; No han pulsado 'S'
 55+  83D9
 56+  83D9              T_S:
 57+  83D9 18 02            JR Soltar_Tecla     ; Esperar q que suelten la tecla
 58+  83DB C9               RET
 59+  83DC
 60+  83DC              T_N:
 61+  83DC C9               RET
 62+  83DD
 63+  83DD              Soltar_Tecla:           ; Rutina de espera hasta que se suelta la tecla
 64+  83DD ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 65+  83DF FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 66+  83E1 20 FA            JR NZ,Soltar_Tecla  ; esperar hasta que no haya tecla pulsada
 67+  83E3 C9               RET
 68+  83E4
 69+  83E4              ;----------------------------------------------------------------------------
 70+  83E4              ; Carga de ficheros y "variables"
 71+  83E4 57 45 4C 43  StartTitle: db "WELCOME TO TETRIS", 0 ;Título del tetris
 71+  83E8 4F 4D 45 20
 71+  83EC 54 4F 20 54
 71+  83F0 45 54 52 49
 71+  83F4 53 00
 72+  83F6 49 6E 69 63  StartQuestion: db "Iniciar una partida? (S/N)", 0 ;Pregunta Inicio
 72+  83FA 69 61 72 20
 72+  83FE 75 6E 61 20
 72+  8402 70 61 72 74
 72+  8406 69 64 61 3F
 72+  840A 20 28 53 2F
 72+  840E 4E 29 00
 73+  8411 48 61 73 20  Respuesta: db "Has contestado: ",0  ; Mensaje con la respuesta
 73+  8415 63 6F 6E 74
 73+  8419 65 73 74 61
 73+  841D 64 6F 3A 20
 73+  8421 00
 74+  8422
 75+  8422
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-inicio.asm
 19   8422                  INCLUDE printat.asm ;Se "importa" la rutina printat
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\printat.asm
  1+  8422              ; -------------------------------
  2+  8422              ; ZX Spectrum Text print library
  3+  8422              ; Daniel León - AOC - UFV 2020
  4+  8422              ; -------------------------------
  5+  8422
  6+  8422
  7+  8422              ; ----------------------------------------------------------------------------------------
  8+  8422              ; PRINTAT - Print a string in a position and attributes as per registers:
  9+  8422              ;		IN	A	: Bit 7=1 For Flash / Bit 6=1 For Brigh / Bit 5,4,3 for Paper / Bit 2,1,0 for Ink
 10+  8422              ;		IN	B	: Row 0..23
 11+  8422              ;		IN	C	: Column 0..31
 12+  8422              ;		IN	IX	: Address of text (Text must end in a 0)
 13+  8422              ; ----------------------------------------------------------------------------------------
 14+  8422 CD 31 84     PRINTAT:	CALL PREP_PRT				; Update Attribute var &Screen & Attributes pointers
 15+  8425              ; ----------------------------------------------------------------------------------------
 16+  8425              ;		VVV Do not move PRINTSTR below as PRINTAT continues into PRINTSTR routine
 17+  8425              ; ----------------------------------------------------------------------------------------
 18+  8425              ; PRINTSTR - Prints String - IX Points to the String start
 19+  8425              ; ----------------------------------------------------------------------------------------
 20+  8425 DD 7E 00     PRINTSTR:   LD A,(IX)					; A Contains first char to print
 21+  8428 B7           			OR A						; check for end of string (0)
 22+  8429 C8           			RET Z						; Finish printing if 0
 23+  842A CD 5F 84     			CALL PRINTCHNUM
 24+  842D DD 23        			INC IX						; Move to next char in string
 25+  842F 18 F4        			JR PRINTSTR					; Start over printing sequence
 26+  8431              ; ----------------------------------------------------------------------------------------
 27+  8431
 28+  8431
 29+  8431              ;-----------------------------------------------------------------------------------------
 30+  8431              ; PREP_PRT - Updates Print_Attr, SCR & ATTR Vars
 31+  8431              ;-----------------------------------------------------------------------------------------
 32+  8431 32 A5 84     PREP_PRT:	LD (PRINT_ATTR),A			; Set Attribute
 33+  8434 CD 3A 84     PREP_PRT_2:	CALL CRtoSCREEN
 34+  8437 C3 4C 84     			JP CRtoATTR
 35+  843A              ;-----------------------------------------------------------------------------------------
 36+  843A
 37+  843A              ;-----------------------------------------------------------------------------------------
 38+  843A              ; CRtoSCREEN - Converts a scr char coord into a SCREEN Address   b,c = y,x positions
 39+  843A              ;	IN  - B=Row, C=Column
 40+  843A              ;	OUT - HL=Address in screen also stored in (SCR_CUR_PTR)
 41+  843A              ;	Conversion:
 42+  843A              ;			Row FFfff   Column CCCCC
 43+  843A              ;			HL=%010FF000 fffCCCCC
 44+  843A              ;-----------------------------------------------------------------------------------------
 45+  843A              CRtoSCREEN:
 46+  843A 78           			LD A,B						; %___FFfff
 47+  843B F6 40        			OR #40						; %010FFfff
 48+  843D E6 F8        			AND #F8						; %010FF000
 49+  843F 67           			LD H,A
 50+  8440
 51+  8440 78           			LD A,B						; %___FFfff
 52+  8441 E6 07        			AND #7						; %00000fff
 53+  8443 0F           			RRCA						; %f00000ff
 54+  8444 0F           			RRCA						; %ff00000f
 55+  8445 0F           			RRCA						; %fff00000
 56+  8446 B1           			OR C						; %fffCCCCC
 57+  8447 6F           			LD L,A
 58+  8448 22 A1 84                 LD (SCR_CUR_PTR),HL			; Update Variable
 59+  844B C9                       RET
 60+  844C              ; ----------------------------------------------------------------------------------------
 61+  844C
 62+  844C
 63+  844C
 64+  844C              ;-----------------------------------------------------------------------------------------
 65+  844C              ; CRtoATTR - Converts a screen char coord  into a ATTR Address  b,c = y,x positions
 66+  844C              ;	IN  - B=Row, C=Column
 67+  844C              ;	OUT - HL=Address in screen also stored in (SCR_ATTR_PTR)
 68+  844C              ;	Conversion:
 69+  844C              ;			Row FFfff   Column CCCCC
 70+  844C              ;			HL=%010110FF fffCCCCC
 71+  844C              ;-----------------------------------------------------------------------------------------
 72+  844C              CRtoATTR:
 73+  844C 78           			LD A,B						; %___FFfff
 74+  844D 0F           			RRCA						; %f000FFff
 75+  844E 0F           			RRCA						; %ff000FFf
 76+  844F 0F           			RRCA						; %fff000FF
 77+  8450 6F           			LD L,A
 78+  8451 E6 03        			AND 3						; %000000FF	value of FF can be only 00,01,10
 79+  8453 F6 58        			OR #58						; %010110FF value will be #58, #59 or #5A
 80+  8455 67           			LD H,A
 81+  8456
 82+  8456 7D           			LD A,L						; %fff000FF
 83+  8457 E6 E0        			AND #E0						; %fff00000
 84+  8459 B1           			OR C						; %fffCCCCC
 85+  845A 6F           			LD L,A
 86+  845B
 87+  845B 22 A3 84                 LD (SCR_ATTR_PTR),HL		; Update Variable
 88+  845E C9                       RET
 89+  845F              ; ----------------------------------------------------------------------------------------
 90+  845F
 91+  845F
 92+  845F
 93+  845F              ; ----------------------------------------------------------------------------------------
 94+  845F              ; PRINTCHNUM - Prints Char Number N (stored in A)
 95+  845F              ;-----------------------------------------------------------------------------------------
 96+  845F              PRINTCHNUM:	;SUB 32						; Adjust Ascii to charset
 97+  845F 26 00        			LD H,0						; Multiply value by 8 to get to right Char in Charset
 98+  8461 6F           			LD L,A
 99+  8462 29           			ADD HL,HL
100+  8463 29           			ADD HL,HL
101+  8464 29           			ADD HL,HL
102+  8465 11 A6 83     			LD DE, CHARSET-(8*32)		; Optimize in compile time (instead of sub 32)
103+  8468 19           			ADD HL,DE
104+  8469 EB           			EX  DE,HL					;Value in DE
105+  846A              			; Continues to printchar below
106+  846A              ; ----------------------------------------------------------------------------------------
107+  846A
108+  846A
109+  846A              ; ----------------------------------------------------------------------------------------
110+  846A              ; PRINTCHAR - Prints Char  (DE points to the char. Uses HL as last Cur Pointer)
111+  846A              ; ----------------------------------------------------------------------------------------
112+  846A              PRINTCHAR:
113+  846A 06 08        			LD B,8						; 8 Lines per char
114+  846C 2A A1 84                 LD HL, (SCR_CUR_PTR)		; Load Cursor Pointer y,x
115+  846F
116+  846F 1A           BYTEPCHAR:	LD A,(DE)					; Get Char to be printed, first line
117+  8470 77           			LD (HL),A					; Move to Printing location
118+  8471 24                       INC H						; inc H so next line in char (ZX Spectrum Screen RAM)
119+  8472 13                       INC DE 						; next line to be printed
120+  8473 10 FA                    DJNZ BYTEPCHAR				; Repeat 8 lines
121+  8475 3A A5 84                 LD A,(PRINT_ATTR) 			; Load Attributes to print char with
122+  8478 2A A3 84                 LD HL, (SCR_ATTR_PTR)
123+  847B 77                       LD (HL),A
124+  847C 21 A3 84                 LD HL, SCR_ATTR_PTR			; Get pointer to ATTR
125+  847F 34                       INC (HL)					; Move Attribute cursor to next char
126+  8480 21 A1 84     			LD HL, SCR_CUR_PTR
127+  8483 34           			INC (HL)					; update Cursor pointer to next position
128+  8484 C9                       RET
129+  8485              ; ----------------------------------------------------------------------------------------
130+  8485
131+  8485
132+  8485
133+  8485              ; ----------------------------------------------------------------------------------------
134+  8485              ; INK2PAPER - moves ink of attribute stored in (PRINT_ATTR) to paper and sets ink to 0
135+  8485              ; 				Sets bright 1 and flash 0
136+  8485              ; ----------------------------------------------------------------------------------------
137+  8485 3A A5 84     INK2PAPER:	LD A, (PRINT_ATTR)		    ; Get storedAttribute
138+  8488 E6 07                    AND 7						; get Attr INK in A
139+  848A 07           			RLCA
140+  848B 07           			RLCA
141+  848C 07           			RLCA						; move Ink to Paper
142+  848D F6 40        			OR 64						; ink 0 bright 1
143+  848F 32 A5 84     			LD (PRINT_ATTR),A		    ; Get storedAttribute
144+  8492 C9           			RET
145+  8493              ; ----------------------------------------------------------------------------------------
146+  8493
147+  8493
148+  8493
149+  8493
150+  8493 21 00 40     CLEARSCR:	LD HL,$4000					; Erases screen by writing 0 to all pixels and attributes
151+  8496 11 01 40     			LD DE,$4001
152+  8499 01 FF 1A     			LD BC,6911
153+  849C 36 00        			LD (HL),0
154+  849E ED B0        			LDIR
155+  84A0 C9           			RET
156+  84A1
157+  84A1
158+  84A1              SCR_CUR_PTR
158+  84A1 00 00          	db $00, $00				; Cursor Pointer in Screen (2 bytes) (HL)
159+  84A3 00 00        SCR_ATTR_PTR: 	db $00, $00				; Attr Pointer in Screen (2 bytes) (HL)
160+  84A5 00           PRINT_ATTR:		db $00					; Attribute used by printchar routine (1 byte)
161+  84A6
162+  84A6              CHARSET: incbin "charset.bin"			; Charset used
163+  87A6
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\printat.asm
 20   87A6                  INCLUDE fichas.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\fichas.asm
  1+  87A6              TETROMINOS:                            ;
  2+  87A6              ;---------------------------------------
  3+  87A6              ;Tetromino O
  4+  87A6 02 02 30 30  T_O: DB 2, 2, 6*8, 6*8, 6*8, 6*8, 0, 0
  4+  87AA 30 30 00 00
  4+  87AE A6 87 A6 87    DW T_O, T_O
  5+  87B2              ;Tetromino L
  6+  87B2 03 02 20 00  T_L1: DB 3, 2, 4*8, 0, 4*8, 0, 4*8, 4*8
  6+  87B6 20 00 20 20
  6+  87BA BE 87 CA 87    DW T_L2, T_L3
  7+  87BE 02 03 00 00  T_L2: DB 2, 3, 0, 0, 4*8, 4*8, 4*8, 4*8
  7+  87C2 20 20 20 20
  7+  87C6 D6 87 B2 87    DW T_L4, T_L1
  8+  87CA 02 03 20 20  T_L3: DB 2, 3, 4*8, 4*8, 4*8, 4*8, 0, 0
  8+  87CE 20 20 00 00
  8+  87D2 B2 87 D6 87    DW T_L1, T_L4
  9+  87D6 03 02 20 20  T_L4: DB 3, 2, 4*8, 4*8, 0, 4*8, 0, 4*8
  9+  87DA 00 20 00 20
  9+  87DE CA 87 BE 87    DW T_L3, T_L2
 10+  87E2              ;Tetromino J
 11+  87E2 03 02 00 10  T_J1: DB 3, 2, 0, 2*8, 0, 2*8, 2*8, 2*8
 11+  87E6 00 10 10 10
 11+  87EA EE 87 FA 87    DW T_J2, T_J3
 12+  87EE 02 03 10 10  T_J2: DB 2, 3, 2*8, 2*8, 2*8, 0, 0, 2*8
 12+  87F2 10 00 00 10
 12+  87F6 06 88 E2 87    DW T_J4, T_J1
 13+  87FA 02 03 10 00  T_J3: DB 2, 3, 2*8, 0, 0, 2*8, 2*8, 2*8
 13+  87FE 00 10 10 10
 13+  8802 E2 87 06 88    DW T_J1, T_J4
 14+  8806 03 02 10 10  T_J4: DB 3, 2, 2*8, 2*8, 2*8, 0, 2*8, 0
 14+  880A 10 00 10 00
 14+  880E FA 87 EE 87    DW T_J3, T_J2
 15+  8812              ;Tetromino T
 16+  8812 02 03 28 28  T_T1: DB 2, 3, 5*8, 5*8, 5*8, 0, 5*8, 0
 16+  8816 28 00 28 00
 16+  881A 1E 88 2A 88    DW T_T2, T_T3
 17+  881E 03 02 28 00  T_T2: DB 3, 2, 5*8, 0, 5*8, 5*8, 5*8, 0
 17+  8822 28 28 28 00
 17+  8826 36 88 12 88    DW T_T4, T_T1
 18+  882A 03 02 00 28  T_T3: DB 3, 2, 0, 5*8, 5*8, 5*8, 0, 5*8
 18+  882E 28 28 00 28
 18+  8832 12 88 36 88    DW T_T1, T_T4
 19+  8836 02 03 00 28  T_T4: DB 2, 3, 0, 5*8, 0, 5*8, 5*8, 5*8
 19+  883A 00 28 28 28
 19+  883E 2A 88 1E 88    DW T_T3, T_T2
 20+  8842              ;Tetromino I
 21+  8842 04 01 30 30  T_I1: DB 4, 1, 6*8, 6*8, 6*8, 6*8, 0, 0
 21+  8846 30 30 00 00
 21+  884A 4E 88 4E 88    DW T_I2, T_I2
 22+  884E 01 04 30 30  T_I2: DB 1, 4, 6*8, 6*8, 6*8, 6*8, 0, 0
 22+  8852 30 30 00 00
 22+  8856 42 88 42 88    DW T_I1, T_I1
 23+  885A              ;Tetromino Z
 24+  885A 02 03 38 38  T_Z1: DB 2, 3, 7*8, 7*8, 0, 0, 7*8, 7*8
 24+  885E 00 00 38 38
 24+  8862 66 88 66 88    DW T_Z2, T_Z2
 25+  8866 03 02 00 38  T_Z2: DB 3, 2, 0, 7*8, 7*8, 7*8, 7*8, 0
 25+  886A 38 38 38 00
 25+  886E 5A 88 5A 88    DW T_Z1, T_Z1
 26+  8872              ;Tetromino S
 27+  8872 02 03 00 18  T_S1: DB 2, 3, 0, 3*8, 3*8, 3*8, 3*8, 0
 27+  8876 18 18 18 00
 27+  887A 7E 88 7E 88    DW T_S2, T_S2
 28+  887E 03 02 18 00  T_S2: DB 3, 2, 3*8, 0, 3*8, 3*8, 0, 3*8
 28+  8882 18 18 00 18
 28+  8886 72 88 72 88    DW T_S1, T_S1
 29+  888A
 30+  888A 00 01 02 03  row_coords: DB 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
 30+  888E 04 05 06 07
 30+  8892 08 09 0A 0B
 30+  8896 0C 0D 0E 0F
 30+  889A 10 11 12 13
 30+  889E 14 15 16
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\fichas.asm
 21   88A1                  INCLUDE Tetris_3D.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\Tetris_3D.asm
  1+  88A1 FF 81 81 85  Tetro_3D:   DB $FF, $81, $81, $85, $85, $9D, $81, $FF ; Patrón para los bloques
  1+  88A5 85 9D 81 FF
  2+  88A9
  3+  88A9              Tetris_3D:
  4+  88A9 16 03            LD D,3              ; Los 3 bloques de píxeles
  5+  88AB DD 21 00 40      LD IX,$4000         ; Dirección de comienzo de la VRAM
  6+  88AF
  7+  88AF              T3D3:
  8+  88AF
  9+  88AF FD 21 A1 88      LD IY,Tetro_3D      ; Primer byte del patrón
 10+  88B3
 11+  88B3 0E 08            LD C,8              ; 8 bytes del patrón
 12+  88B5              T3D2:
 13+  88B5 06 00            LD B,0              ; 256 bytes de cada línea del patrón
 14+  88B7 FD 7E 00         LD a,(IY)           ; Cargo el valor del patrón
 15+  88BA              T3D1:
 16+  88BA DD 77 00         LD (IX),a           ; Cargo el patrón en la VideoRam
 17+  88BD DD 23            INC IX              ; Siguientes 8 pixels
 18+  88BF 10 F9            DJNZ T3D1           ; Fin del bucle
 19+  88C1
 20+  88C1 0D               DEC C               ; Fin del 2º Bucle
 21+  88C2 FD 23            inc IY              ; Siguiente byte del patrón
 22+  88C4 20 EF            JR NZ,T3D2
 23+  88C6
 24+  88C6 15               DEC D               ; Fin del 3º bucle
 25+  88C7 20 E6            JR NZ, T3D3
 26+  88C9
 27+  88C9 C9               RET
 28+  88CA
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\Tetris_3D.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\main.asm
