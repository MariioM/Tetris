# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\main.asm
  1   0000                  DEVICE ZXSPECTRUM48 ;Especificacion para el emulador                    ;
  2   0000                  ORG $8000 ;Programa empieza en $8000                                    ;
  3   8000 31 00 00         LD SP, 0 ;Carga del stack en 0                                          ;
  4   8003              ;Rutina principal del juego encargada de llamar a las rutinas principales   ;
  5   8003              ;---------------------------------------------------------------------------;
  6   8003              gameStart:
  7   8003 CD 85 83         CALL STARTSCREEN ;Se llama a la pantalla de inicio
  8   8006              gameInit:
  9   8006 CD 77 80         CALL MAINGAME ;Se llama al juego
 10   8009              gameEnd:
 11   8009 CD 12 80         CALL ENDSCREEN ;Se llama a la pantalla final
 12   800C FE 68            CP 104 ;Se comprueba si se quiere jugar de nuevo
 13   800E 20 F3            JR NZ , gameStart
 14   8010
 15   8010 18 FE        mainEnd: JR mainEnd ;Se queda en un bucle infinito
 16   8012              ;-------------------------------------------------------------------
 17   8012                  INCLUDE pantalla-final.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-final.asm
  1+  8012              ENDSCREEN:
  2+  8012 CD 99 84         CALL CLEARSCR
  3+  8015              ;Muestra la pantalla de game over
  4+  8015              ;--------------------------------------------------
  5+  8015              ;Imprime el GAME OVER
  6+  8015 3E 82            LD A,2+$80 ; Se da formato de color al texto
  7+  8017 06 0A            LD B,10    ; Coordenada de la fila
  8+  8019 0E 0C            LD C,12     ; Coordenada de la columna
  9+  801B DD 21 51 80      LD IX, GameOverText   ; Se añade el título
 10+  801F CD 28 84         CALL PRINTAT
 11+  8022
 12+  8022 3E 03            LD A,3 ; Se da formato de color al texto
 13+  8024 06 0E            LD B, 14    ; Coordenada de la fila
 14+  8026 0E 04            LD C,4    ; Coordenada de la columna
 15+  8028 DD 21 5B 80      LD IX, ContinueText   ; Se añade el título
 16+  802C CD 28 84         CALL PRINTAT
 17+  802F CD 32 80         CALL TecladoFinal   ; Se lee el input del teclado hasta que se pulse S o N
 18+  8032
 19+  8032              ;Rutina que guarda lo que pulsa el usuario
 20+  8032              TecladoFinal:          ; Rutina para leer del teclado 'S' o 'N'
 21+  8032 01 FE 7F         LD BC,$7FFE         ; Escanear línea B,N,M,SYMB,Space
 22+  8035 ED 78            IN A,(C)
 23+  8037 CB 5F            BIT 3,A
 24+  8039 28 0E            JR Z,T_N_Final            ; Han pulsado N
 25+  803B 01 FE FD         LD BC,$FDFE         ; Escanear línea G,F,D,S,A
 26+  803E ED 78            IN A,(C)
 27+  8040 CB 4F            BIT 1,A
 28+  8042 20 EE            JR NZ,TecladoFinal       ; No han pulsado 'S'
 29+  8044
 30+  8044              T_S_final:
 31+  8044 18 04            JR Soltar_Tecla_Final     ; Esperar q que suelten la tecla
 32+  8046 3E 68            LD A, 104          ; Se guarda el valor 104 en A para nueva partida
 33+  8048 C9               RET
 34+  8049
 35+  8049              T_N_Final:
 36+  8049 C9               RET
 37+  804A
 38+  804A              Soltar_Tecla_Final:           ; Rutina de espera hasta que se suelta la tecla
 39+  804A ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 40+  804C FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 41+  804E 20 FA            JR NZ,Soltar_Tecla_Final  ; esperar hasta que no haya tecla pulsada
 42+  8050 C9               RET
 43+  8051
 44+  8051
 45+  8051
 46+  8051
 47+  8051              ;---------------------------------------------------------
 48+  8051 47 41 4D 45  GameOverText: db "GAME OVER", 0 ; Texto de fin de partida
 48+  8055 20 4F 56 45
 48+  8059 52 00
 49+  805B 44 65 73 65  ContinueText: db "Desea jugar de nuevo? (S/N)", 0 ; Pregunta continue
 49+  805F 61 20 6A 75
 49+  8063 67 61 72 20
 49+  8067 64 65 20 6E
 49+  806B 75 65 76 6F
 49+  806F 3F 20 28 53
 49+  8073 2F 4E 29 00
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-final.asm
 18   8077                  INCLUDE game.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\game.asm
  1+  8077              MAINGAME:                                           ;
  2+  8077 CD 99 84         CALL CLEARSCR  ;Limpia la pantalla              ;
  3+  807A              ;Rutina encargada de manejar el flujo del juego     ;
  4+  807A              ;----------------------------------------------------
  5+  807A CD 8F 80         CALL CREATEBOARD ; Crea el tablero
  6+  807D              gameflow:
  7+  807D CD 1C 82         CALL RANDOMTETRO ; Geneta un tetromino aleatorio
  8+  8080 3E 0E            LD A, 14
  9+  8082 32 59 82         LD (Middle), A
 10+  8085 CD 39 81         CALL TETRODOWN ; Llama a la funcion que dibuja y mueve el tetromino hacia abajo
 11+  8088 FE FE            CP 254 ;Comprueba el gaemover
 12+  808A 20 F1            JR NZ, gameflow ;Si no es gameover, sigue el juego
 13+  808C C9               RET ; Si es gameover, sale del juego
 14+  808D
 15+  808D 18 FE        fin: JR fin
 16+  808F              ;-----------------------------------------
 17+  808F                  INCLUDE create-board.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\create-board.asm
  1++ 808F              CREATEBOARD:                              ;
  2++ 808F CD 99 84         CALL CLEARSCR                         ;
  3++ 8092              ANCHO EQU 14                              ;
  4++ 8092              LARGO EQU 22                              ;
  5++ 8092              ;Dibuja el marco del tablero de juego     ;
  6++ 8092              ;------------------------------------------
  7++ 8092 CD AF 88         CALL Tetris_3D
  8++ 8095 3E 20            LD A, 32 ; Se carga en A el ancho de la pantalla
  9++ 8097 D6 02            SUB 2 ;Se le resta 2, que serán las columnas de los bordes
 10++ 8099 D6 0E            SUB ANCHO ;Se le resta el ancho del tablero
 11++ 809B CB 3F            SRL A ;Se divide
 12++ 809D 4F               LD C, A
 13++ 809E 3E 00            LD A, 0
 14++ 80A0 C6 1F            ADD (32 - 1)
 15++ 80A2 47               LD B, A
 16++ 80A3 21 00 58         LD HL, $5800 ; Se guarda la dirección de memoria donde se guardan los atributos de la pantalla
 17++ 80A6              bucle1:
 18++ 80A6 23               INC HL ; Se incrementa la dirección de memoria
 19++ 80A7 10 FD            DJNZ bucle1 ; Se repite hasta que completa toda la fila vacía
 20++ 80A9 06 16            LD B, LARGO
 21++ 80AB              bucle:
 22++ 80AB C5               PUSH BC
 23++ 80AC 41               LD B, C
 24++ 80AD              marco_izq: ;Se deja espacio para el marco izquierdo
 25++ 80AD 23               INC HL
 26++ 80AE 10 FD            DJNZ marco_izq
 27++ 80B0 C5               PUSH BC
 28++ 80B1              margenizq: ;Se pinta todo el borde izquierdo de blanco
 29++ 80B1 23               INC HL
 30++ 80B2 0E 07            LD C, 7
 31++ 80B4 79               LD A, C
 32++ 80B5 87               ADD A
 33++ 80B6 87               ADD A
 34++ 80B7 87               ADD A
 35++ 80B8 77               LD (HL), A
 36++ 80B9 3E 00            LD A, 0
 37++ 80BB 06 0E            LD B, ANCHO
 38++ 80BD 80               ADD B
 39++ 80BE 47               LD B, A
 40++ 80BF              comienzo_ancho:
 41++ 80BF 23               INC HL
 42++ 80C0 10 FD            DJNZ comienzo_ancho ;Se deja el ancho del tablero sin pintar
 43++ 80C2              margendrcho: ;Se pinta el borde derecho
 44++ 80C2 23               INC HL
 45++ 80C3 0E 07            LD C,7
 46++ 80C5 79               LD A, C
 47++ 80C6 87               ADD A
 48++ 80C7 87               ADD A
 49++ 80C8 87               ADD A
 50++ 80C9 77               ld (HL), A
 51++ 80CA
 52++ 80CA C1               POP BC
 53++ 80CB 41               LD B, C
 54++ 80CC              marco_drcho: ;Se deja espacio después del marco derecho
 55++ 80CC 23               INC HL
 56++ 80CD 10 FD            DJNZ marco_drcho
 57++ 80CF C1               POP BC
 58++ 80D0 10 D9            DJNZ bucle
 59++ 80D2
 60++ 80D2 41               LD B, C
 61++ 80D3              marco_izq_fila_ult:;Se deja espacio para el marco izquierdo de la última fila
 62++ 80D3 23               INC HL
 63++ 80D4 10 FD            DJNZ marco_izq_fila_ult
 64++ 80D6              fila_ultima: ;Se reserva el espacio de la última fila
 65++ 80D6 06 10            LD B, ANCHO + 2
 66++ 80D8              bucle2: ;Se pinta la última fila de blanco
 67++ 80D8 23               INC HL
 68++ 80D9 0E 07            LD C,7
 69++ 80DB 79               LD A, C
 70++ 80DC 87               ADD A
 71++ 80DD 87               ADD A
 72++ 80DE 87               ADD A
 73++ 80DF 77               ld (HL), A
 74++ 80E0 10 F6            DJNZ bucle2
 75++ 80E2
 76++ 80E2 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\create-board.asm
 18+  80E3                  INCLUDE draw-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-tetro.asm
  1++ 80E3              DRAWTETRO:
  2++ 80E3              ;Rutina encargada de dibujar una pieza en la pantalla.
  3++ 80E3              ;Para ello utiliza la rutina DRAWPIXEL, que se encarga de dibujar pixel a pixel el tetrominó.
  4++ 80E3              ;---------------------------------------------
  5++ 80E3 DD 7E 00         LD A, (IX)  ; Se carga el valor de la pieza
  6++ 80E6 57               LD D, A ; Se guarda en D
  7++ 80E7 DD 23            INC IX
  8++ 80E9 3A 53 82         LD A, (IXCounter)
  9++ 80EC 3C               INC A
 10++ 80ED 32 53 82         LD (IXCounter), A
 11++ 80F0 DD 7E 00         LD A, (IX)
 12++ 80F3 5F               LD E, A
 13++ 80F4 42               LD B, D
 14++ 80F5              drawfilas:
 15++ 80F5 C5               PUSH BC ; Se guarda el valor de B
 16++ 80F6 43               LD B, E ; Se carga el número de columnas
 17++ 80F7              drawcolumnas:
 18++ 80F7 50               LD D, B ; Se carga el número de columnas
 19++ 80F8 DD 23            INC IX
 20++ 80FA 3A 53 82         LD A, (IXCounter)
 21++ 80FD 3C               INC A
 22++ 80FE 32 53 82         LD (IXCounter), A
 23++ 8101 DD 7E 00         LD A, (IX)
 24++ 8104 C1               POP BC ; Se recupera el valor de B
 25++ 8105 4A               LD C, D ; Se carga la posición del pixel a dibujar
 26++ 8106 CD 11 81         CALL DRAWPIXEL ; Se dibuja el pixel
 27++ 8109 C5               PUSH BC
 28++ 810A 42               LD B, D ;Se decrementa el número de columnas restantes
 29++ 810B 10 EA            DJNZ drawcolumnas ;Comprueba que se hayan pintado todas las columnas
 30++ 810D C1               POP BC ; Se recupera el valor de B
 31++ 810E 10 E5            DJNZ drawfilas ;Comprueba que se hayan pintado todas las filas
 32++ 8110
 33++ 8110 C9               RET
 34++ 8111              ;------------------------------------------
 35++ 8111                  INCLUDE draw-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-pixel.asm
  1+++8111              DRAWPIXEL:
  2+++8111 F5               PUSH AF
  3+++8112 D5               PUSH DE ;Se guardan todos los registros
  4+++8113 F5               PUSH AF
  5+++8114 C5               PUSH BC
  6+++8115              ;Rutina encargada de dibujar un pixel en la pantalla
  7+++8115              ;------------------------------------------------------
  8+++8115 78               LD A, B ;Se carga la posicion en A
  9+++8116 FD 86 00         ADD (IY) ;Se suma la posicion con la posicion del tetro
 10+++8119 47               LD B, A ; Se carga la posición actualizada en B
 11+++811A 68               LD L, B
 12+++811B 26 00            LD H, 0 ; HL = B
 13+++811D
 14+++811D 29               ADD HL, HL
 15+++811E 29               ADD HL, HL
 16+++811F 29               ADD HL, HL
 17+++8120 29               ADD HL, HL
 18+++8121 29               ADD HL, HL; HL = HL *32
 19+++8122 3A 59 82         LD A, (Middle) ;Se carga la posición del tetro en el eje X
 20+++8125 81               ADD C  ;
 21+++8126 4F               LD C, A
 22+++8127 59               LD E, C
 23+++8128 16 00            LD D, 0 ; DE = C
 24+++812A 19               ADD HL, DE ;Se cargan los atributos
 25+++812B 11 00 58         LD DE, $5800
 26+++812E 19               ADD HL, DE ; HL = Y*32 + X + $5800
 27+++812F C1               POP BC
 28+++8130 F1               POP AF
 29+++8131 FE 00            CP 0
 30+++8133 28 01            JR Z, tetroExistDraw ;Si el valor es 0, no se dibuja
 31+++8135 77               LD (HL), A
 32+++8136              tetroExistDraw:
 33+++8136 D1               POP DE
 34+++8137 F1               POP AF
 35+++8138 C9               RET
 36+++8139              ;------------------------------------------------
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\draw-tetro.asm
 19+  8139                  INCLUDE tetro-down.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-down.asm
  1++ 8139              TETRODOWN:
  2++ 8139              ;Rutina encargada de bajar el tetromino.
  3++ 8139              ;Contiene también las funcionalidades de mover/rotar el tetromino y de comprobar si hay colisión.
  4++ 8139              ;--------------------------------------------------------------------------------------------------
  5++ 8139 FD 21 90 88      LD IY, row_coords ;Se carga la direccion de memoria de la fila
  6++ 813D CD 5B 82         CALL CHECKCOLISION ;Se llama a la funcion que revisa si hay colision
  7++ 8140 FE 64            CP 100 ;Se comprueba la condición de derrota
  8++ 8142 28 6E            JR Z, goGameOver ;Si se va a la funcion de GameOver
  9++ 8144 CD 0E 82         CALL LASTPOSITION ;Si no, se llama a la funcion que devuelve IX
 10++ 8147
 11++ 8147              down:
 12++ 8147 C5               PUSH BC ;Se guarda el valor de BC
 13++ 8148 CD E3 80         CALL DRAWTETRO ;Se llama a la funcion que dibuja el tetromino
 14++ 814B CD 0E 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 15++ 814E CD 42 82         CALL TETRODELAY ;Se llama a la funcion que hace el tiempo de espera
 16++ 8151 CD B7 81         CALL TETRODEL ;Se llama a la funcion que borra el tetromino
 17++ 8154 CD 0E 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 18++ 8157 FD 23            INC IY ;Se incrementa la fila
 19++ 8159 CD FB 82         CALL TETROMOVE ;Se llama a la funcion que comprueba el movimiento del tetromino
 20++ 815C CD CC 82         CALL TURNTETRO ;Se llama a la funcion que comprueba el giro el tetromino
 21++ 815F CD 5B 82         CALL CHECKCOLISION ;Se llama a la funcion que comprueba si hay colision
 22++ 8162 FE 64            CP 100 ;Se comprueban las colisiones
 23++ 8164 28 0B            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 24++ 8166 20 00            JR NZ, downcontinue ;Si no, se continua bajando
 25++ 8168
 26++ 8168              downcontinue:
 27++ 8168 CD 2D 83         CALL DELROW ;Se llama a la funcion que comprueba si hay fila completa
 28++ 816B CD 0E 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 29++ 816E C1               POP BC ;Se recupera el valor de BC
 30++ 816F 18 D6            JR down ;Continua la función de bajar pieza
 31++ 8171              nexttetro:
 32++ 8171 CD 0E 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 33++ 8174 3A 59 82         LD A, (Middle) ;Se carga el valor de la variable Middle, que contiene la posición del tetro respecto al centro
 34++ 8177 FE 07            CP 7
 35++ 8179 28 28            JR Z, left_wall
 36++ 817B FE 08            CP 8
 37++ 817D 28 24            JR Z, left_wall ;Se comprueban las colisiones con las paredes izquierda y derecha
 38++ 817F FE 14            CP 20
 39++ 8181 28 11            JR Z, right_wall
 40++ 8183 FE 15            CP 21
 41++ 8185 28 0D            JR Z, right_wall
 42++ 8187 C1               POP BC ;Se recupera el valor de BC
 43++ 8188 FD 2B            DEC IY ;Se decrementa la fila
 44++ 818A CD E3 80         CALL DRAWTETRO ;Se llama a la funcion que dibuja el tetromino
 45++ 818D CD 0E 82         CALL LASTPOSITION ;Se llama a la funcion que devuelve IX
 46++ 8190 CD 36 82         CALL RETURNIY ;Se llama a la funcion que devuelve IY
 47++ 8193 C9               RET ;Se sale de la rutina hacia el main (Tetro posicionado)
 48++ 8194              right_wall:
 49++ 8194 3D               DEC A ;Si se colisiona con la pared derecha, mueve el tetro hacia la izquierda
 50++ 8195 32 59 82         LD (Middle), A ;Realiza el cambio de posición
 51++ 8198 CD 5B 82         CALL CHECKCOLISION ;Se comprueba si hay colisisión
 52++ 819B FE 64            CP 100
 53++ 819D 28 D2            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 54++ 819F 20 C7            JR NZ, downcontinue ;Si no, se continua bajando
 55++ 81A1 18 A4            JR down
 56++ 81A3              left_wall:
 57++ 81A3 3C               INC A ;Si se colisiona con la pared izquierda, mueve el tetro hacia la derecha
 58++ 81A4 32 59 82         LD (Middle), A ;Realiza el cambio de posición
 59++ 81A7 CD 5B 82         CALL CHECKCOLISION ;Se comprueba si hay colisisión
 60++ 81AA FE 64            CP 100
 61++ 81AC 28 C3            JR Z, nexttetro ;Si hay colisión, se va a la siguiente pieza
 62++ 81AE 20 B8            JR NZ, downcontinue ;Si no, se continua bajando
 63++ 81B0
 64++ 81B0 18 95            JR down
 65++ 81B2              goGameOver:
 66++ 81B2 C1               POP BC ;Se recupera el valor de BC
 67++ 81B3 3E FE            LD A, 254 ;Se carga el valor de 254 en A para comprobar la derrota
 68++ 81B5 C9               RET ;Vueleve al main
 69++ 81B6              gamecontinue:
 70++ 81B6 C9               RET
 71++ 81B7              ;----------------------------------------------------
 72++ 81B7                  INCLUDE del-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-tetro.asm
  1+++81B7              TETRODEL:
  2+++81B7              ;Borra la pieza actual del tablero. Para ello, llama a DELPIXEL con las coordenadas de cada uno de los píxeles que forman la pieza.
  3+++81B7              ;------------------------------------------------------
  4+++81B7 DD 7E 00         LD A, (IX) ; Se carga en A el tetrominó actual
  5+++81BA 57               LD D, A ; Se guarda en D el tetrominó actual
  6+++81BB DD 23            INC IX
  7+++81BD 3A 53 82         LD A, (IXCounter)
  8+++81C0 3C               INC A
  9+++81C1 32 53 82         LD (IXCounter), A
 10+++81C4 DD 7E 00         LD A, (IX)
 11+++81C7 5F               LD E, A ;Se guardan las columnas en E
 12+++81C8 42               LD B, D ;Se guardan las filas en B
 13+++81C9              rowdel:
 14+++81C9 C5               PUSH BC ;Se guarda en la pila el valor de B
 15+++81CA 43               LD B, E ;Se cargan las columnas en B
 16+++81CB              columndel:
 17+++81CB 50               LD D, B
 18+++81CC DD 23            INC IX ;Se incrementa IX para que apunte a la siguiente posición
 19+++81CE 3A 53 82         LD A, (IXCounter)
 20+++81D1 3C               INC A
 21+++81D2 32 53 82         LD (IXCounter), A
 22+++81D5 DD 7E 00         LD A, (IX)
 23+++81D8 C1               POP BC
 24+++81D9 4A               LD C, D ;Se carga la posición del pixel a borrar en C
 25+++81DA CD E5 81         CALL DELPIXEL ;Se borra el pixel en las coordenadas indicadas
 26+++81DD C5               PUSH BC
 27+++81DE 42               LD B, D
 28+++81DF 10 EA            DJNZ columndel ;Se repite el bucle hasta que se borren todas las columnas
 29+++81E1 C1               POP BC ;Se recupera el valor de B
 30+++81E2 10 E5            DJNZ rowdel ;Se repite el bucle hasta que se borren todas las filas
 31+++81E4
 32+++81E4 C9               RET
 33+++81E5              ;-----------------------------------------
 34+++81E5                  INCLUDE del-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-pixel.asm
  1+++81E5              DELPIXEL:
  2+++81E5              ;Borra un pixel
  3+++81E5              ;--------------------------------------------------
  4+++81E5 F5               PUSH AF
  5+++81E6 D5               PUSH DE
  6+++81E7 F5               PUSH AF
  7+++81E8 C5               PUSH BC
  8+++81E9
  9+++81E9 78               LD A, B ; Se carga la posición en A
 10+++81EA FD 86 00         ADD (IY) ; Se suma la fila
 11+++81ED 47               LD B, A ; Se guarda la posición en B
 12+++81EE 68               LD L, B
 13+++81EF 26 00            LD H, 0 ; HL = B
 14+++81F1
 15+++81F1 29               ADD HL, HL
 16+++81F2 29               ADD HL, HL
 17+++81F3 29               ADD HL, HL
 18+++81F4 29               ADD HL, HL
 19+++81F5 29               ADD HL, HL; HL = HL *32
 20+++81F6 3A 59 82         LD A, (Middle) ; Se carga la posición en A
 21+++81F9 81               ADD C
 22+++81FA 4F               LD C, A
 23+++81FB 59               LD E, C
 24+++81FC 16 00            LD D, 0 ; DE = C
 25+++81FE 19               ADD HL, DE ;Se cargan los atributos del tetro
 26+++81FF 11 00 58         LD DE, $5800
 27+++8202 19               ADD HL, DE ; HL = Y*32 + X + $5800
 28+++8203 C1               POP BC
 29+++8204 F1               POP AF
 30+++8205 FE 00            CP 0
 31+++8207 28 02            JR Z, tetroExist ;Si el valor es 0, no se borrará nada
 32+++8209 36 00            LD (HL), 0
 33+++820B              tetroExist:
 34+++820B D1               POP DE
 35+++820C F1               POP AF
 36+++820D C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-tetro.asm
 73++ 820E                  INCLUDE last-position.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\last-position.asm
  1+++820E              LASTPOSITION:                                                   ;
  2+++820E              ;Rutina encargada de controlar los cambios sobre los tetrominos ;
  3+++820E              ;---------------------------------------------------------------;
  4+++820E 3A 53 82         LD A, (IXCounter) ;Se carga en A el valor de IXCounter
  5+++8211 47               LD B, A
  6+++8212              return:
  7+++8212 DD 2B            DEC IX
  8+++8214 10 FC            DJNZ return
  9+++8216
 10+++8216 3E 00            LD A, 0
 11+++8218 32 53 82         LD (IXCounter), A
 12+++821B C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\last-position.asm
 74++ 821C                  INCLUDE tetro-random.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-random.asm
  1+++821C              RANDOMTETRO:
  2+++821C              ;Rutina encargada de cargar un tetrominó aleatorio
  3+++821C              ;-------------------------------------------------
  4+++821C
  5+++821C ED 5F            LD A, R ;Se carga en A un número aleatorio entre 0 y 255
  6+++821E E6 1F            AND 31 ;Se hace un AND con 31 para que el número esté entre 0 y 31
  7+++8220 FE 13            CP 19 ;Se compara con 19, si es menor
  8+++8222 38 02            JR C, continue ;Si es menor que 19, se carga el tetrominó
  9+++8224 D6 13            SUB 19 ;Si es mayor, se le resta 19
 10+++8226              continue:
 11+++8226 DD 21 AC 87      LD IX, T_O ;Se carga el tetrominó O
 12+++822A 11 0C 00         LD DE, ANCHOTETRO ;Se guarda el ancho de palabra del tetrominó
 13+++822D B7               OR A ;Si es 0, se termina la rutina y se pinta el tetrominó O
 14+++822E 28 05            JR Z, randomend
 15+++8230              more:
 16+++8230 DD 19            ADD IX, DE ;Si no lo es, se pasa al siguiente tetrominó
 17+++8232 3D               DEC A
 18+++8233 20 FB            JR NZ, more ;Se repite hasta que se llegue a la dirección de memoria del tretrominó a pintar
 19+++8235
 20+++8235              randomend:
 21+++8235 C9               RET
 22+++8236              ;-------------------------------
 23+++8236              ANCHOTETRO EQU T_L1 - T_O
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-random.asm
 75++ 8236                  INCLUDE IYReturn.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\IYReturn.asm
  1+++8236              RETURNIY:                                         ;
  2+++8236              ;Rutina encargada de guardar las filas restantes  ;
  3+++8236              ;-------------------------------------------------;
  4+++8236 FD 7E 00         LD A, (IY) ; Se guarda en A la direccuón de memoria a la que apunta IY
  5+++8239 FE 00            CP 0 ; Se compara con 0
  6+++823B 28 04            JR Z, final ; Si es 0, se sale del programa
  7+++823D FD 2B            DEC IY ; Si no, se decrementa IY
  8+++823F 18 F5            JR RETURNIY ;Hasta que sea 0
  9+++8241
 10+++8241
 11+++8241              final:
 12+++8241 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\IYReturn.asm
 76++ 8242                  INCLUDE delay-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\delay-tetro.asm
  1+++8242              TETRODELAY:
  2+++8242              ;Establece un tiempo de espera para los movimientos de las piezas
  3+++8242              ;------------------------------------------
  4+++8242 21 98 3A         LD HL, 15000 ; Se impone un tiempo de espera entre movimiento y movimiento
  5+++8245              delayloop:
  6+++8245 2B               DEC HL
  7+++8246 7C               LD A, H
  8+++8247 F6 00            OR 0 ;Se va decerementando el registro HL hasta que sea 0
  9+++8249 20 FA            JR NZ, delayloop
 10+++824B C9               RET ;Cuando pase el tiempo, se sigue el programa
 11+++824C
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\delay-tetro.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-down.asm
 20+  824C                  INCLUDE position-coords.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\position-coords.asm
  1++ 824C              gamestatusstruct:
  2++ 824C              ;Rutina encargada de almacenar variables de estado del juego
  3++ 824C              ;-----------------------------------------------------------
  4++ 824C
  5++ 824C 00           GameX: DB 0
  6++ 824D 00           GameY: DB 0
  7++ 824E 00 00        TetroPtr: DW 0
  8++ 8250 00 00        DownCounter: DW 0
  9++ 8252 00           UndoKey: DB 0
 10++ 8253 00           IXCounter: DB 0
 11++ 8254 00           PosibleColor: DB 0
 12++ 8255 00           NewColor: DB 0
 13++ 8256 00           OldColor: DB 0
 14++ 8257 00           GameXPosible: DB 0
 15++ 8258 00           GameYPosible: DB 0
 16++ 8259 0E           Middle: DB 14
 17++ 825A 00           FilaCompleta: DB 0
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\position-coords.asm
 21+  825B                  INCLUDE check-colision.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-colision.asm
  1++ 825B              CHECKCOLISION:
  2++ 825B              ;Rutina que comprueba si un tetrominó colisiona con una pared o con otro tetrominó
  3++ 825B              ;--------------------------------------------
  4++ 825B DD 7E 00         LD A, (IX)
  5++ 825E 57               LD D, A
  6++ 825F DD 23            INC IX
  7++ 8261 3A 53 82         LD A, (IXCounter)
  8++ 8264 3C               INC A
  9++ 8265 32 53 82         LD (IXCounter), A
 10++ 8268 DD 7E 00         LD A, (IX)
 11++ 826B 5F               LD E, A
 12++ 826C 42               LD B, D
 13++ 826D              fil:
 14++ 826D C5               PUSH BC
 15++ 826E 43               LD B, E
 16++ 826F              cols:
 17++ 826F 50               LD D, B
 18++ 8270 DD 23            INC IX
 19++ 8272 3A 53 82         LD A, (IXCounter)
 20++ 8275 3C               INC A
 21++ 8276 32 53 82         LD (IXCounter), A
 22++ 8279 DD 7E 00         LD A, (IX)
 23++ 827C 32 55 82         LD (NewColor), A ;Guardamos el color del pixel que queremos pintar en ColorNuevo
 24++ 827F C1               POP BC
 25++ 8280 4A               LD C, D
 26++ 8281 CD AA 82         CALL comprobarpunto ;A=color, B=fila, C=columna
 27++ 8284 32 56 82         LD (OldColor), A ;comprobarpunto nos devuelve el color que había antes de pintar el pixel nuevo, por lo que lo almacenamos en ColorViejo
 28++ 8287 78               LD A, B
 29++ 8288 32 57 82         LD (GameXPosible), A
 30++ 828B 79               LD A, C
 31++ 828C 32 58 82         LD (GameYPosible), A
 32++ 828F 3A 56 82         LD A, (OldColor)
 33++ 8292 FE 00            CP 0 ;Si dicho ColorViejo es negro, se podrá continuar comprobando los demás pixeles.
 34++ 8294 28 0C            JR Z, no_hay_color ;Si encontramos un color viejo existente, saltamos a ver los casos posibles
 35++ 8296              puede_haber_color:
 36++ 8296 3A 55 82         LD A, (NewColor)
 37++ 8299 FE 00            CP 0  ;En el caso de que haya color viejo, tenemos que observar si el color del pixel
 38++ 829B 20 02            JR NZ, hay_color ;nuevo es negro o no, ya que en dicho caso no colisionarían colores.
 39++ 829D 28 03            JR Z, no_hay_color
 40++ 829F              hay_color: ;Si existe un color viejo y nuevo, colisiona, por lo que habrá que ver si se trata de una pared o no.
 41++ 829F 3E 64            LD A, 100
 42++ 82A1 C9               RET
 43++ 82A2              no_hay_color: ;En caso de no haber un color, comprueba otro pixel
 44++ 82A2 C5               PUSH BC
 45++ 82A3 42               LD B, D
 46++ 82A4 10 C9            DJNZ cols ;Comprueba todas las columnas
 47++ 82A6 C1               POP BC
 48++ 82A7 10 C4            DJNZ fil ;Comprueba todas las filas
 49++ 82A9
 50++ 82A9 C9               RET
 51++ 82AA              ;----------------------------------------
 52++ 82AA                  INCLUDE check-pixel.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-pixel.asm
  1+++82AA              comprobarpunto:
  2+++82AA              ;Rutina que comprueba pixel a a pixel la colisión con algún elemento del tablero
  3+++82AA              ;-------------------------------------------------------
  4+++82AA D5               PUSH DE
  5+++82AB F5               PUSH AF
  6+++82AC C5               PUSH BC
  7+++82AD
  8+++82AD 68               LD L, B
  9+++82AE FD 7E 00         LD A, (IY)
 10+++82B1 85               ADD L
 11+++82B2 6F               LD L, A
 12+++82B3 26 00            LD H, 0 ; HL = B
 13+++82B5 29               ADD HL, HL
 14+++82B6 29               ADD HL, HL
 15+++82B7 29               ADD HL, HL
 16+++82B8 29               ADD HL, HL
 17+++82B9 29               ADD HL, HL; HL = HL *32
 18+++82BA 3A 59 82         LD A, (Middle) ;Guarda en A la posición del tetro respecto al centro
 19+++82BD 81               ADD C
 20+++82BE 4F               LD C, A
 21+++82BF 59               LD E, C
 22+++82C0 16 00            LD D, 0 ; DE = C
 23+++82C2 19               ADD HL, DE
 24+++82C3 11 00 58         LD DE, $5800
 25+++82C6 19               ADD HL, DE ; HL = Y*32 + X + $5800
 26+++82C7 C1               POP BC
 27+++82C8 F1               POP AF
 28+++82C9 D1               POP DE
 29+++82CA 7E               LD A, (HL)
 30+++82CB C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-pixel.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\check-colision.asm
 22+  82CC                  INCLUDE turn-tetro.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\turn-tetro.asm
  1++ 82CC              TURNTETRO:
  2++ 82CC              ;Rutina encargada de controlar la rotación de la pieza
  3++ 82CC              ;--------------------------------------------------------------------
  4++ 82CC
  5++ 82CC 01 FE FB         LD BC,$FBFE        ; Escanear línea  T,R,E,W,Q
  6++ 82CF ED 78            IN A,(C)
  7++ 82D1 CB 47            BIT 0,A
  8++ 82D3 28 12            JR Z, turn_left    ; Han pulsado Q -> Girar izquierda
  9++ 82D5 CB 4F            BIT 1,A
 10++ 82D7 28 02            JR Z, turn_right  ; Han pulsado W -> Girar derecha
 11++ 82D9 18 1F            JR no_tecla         ; No hay tecla pulsada
 12++ 82DB
 13++ 82DB              turn_right:
 14++ 82DB DD 6E 0A         LD L, (IX + 10)
 15++ 82DE DD 66 0B         LD H, (IX + 11)
 16++ 82E1 E5 DD E1         LD IX, HL
 17++ 82E4 18 0D            JR SoltarTecla     ; Esperar que suelten la tecla
 18++ 82E6 C9               RET
 19++ 82E7
 20++ 82E7              turn_left:
 21++ 82E7 DD 6E 08         LD L, (IX + 8)
 22++ 82EA DD 66 09         LD H, (IX + 9)
 23++ 82ED E5 DD E1         LD IX, HL
 24++ 82F0 18 01            JR SoltarTecla     ; Esperar que suelten la tecla
 25++ 82F2 C9               RET
 26++ 82F3
 27++ 82F3
 28++ 82F3              SoltarTecla:           ; Rutina de espera hasta que se suelta la tecla
 29++ 82F3 ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 30++ 82F5 FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 31++ 82F7 20 FA            JR NZ,SoltarTecla  ; esperar hasta que no haya tecla pulsada
 32++ 82F9 C9               RET
 33++ 82FA
 34++ 82FA              no_tecla:
 35++ 82FA C9               RET
 36++ 82FB
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\turn-tetro.asm
 23+  82FB                  INCLUDE tetro-move.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-move.asm
  1++ 82FB              TETROMOVE:
  2++ 82FB              ;Rutina encargada de controlar el movimiento de la pieza
  3++ 82FB              ;--------------------------------------------------------
  4++ 82FB
  5++ 82FB 01 FE BF         LD BC,$BFFE       ; Escanear línea  H,J,K,L,ENTER
  6++ 82FE ED 78            IN A,(C)
  7++ 8300 CB 5F            BIT 3,A
  8++ 8302 28 14            JR Z, move_left    ; Han pulsado J -> Mover izquierda
  9++ 8304 CB 57            BIT 2,A
 10++ 8306 28 06            JR Z, move_right  ; Han pulsado K -> Mover derecha
 11++ 8308 CB 47            BIT 0,A
 12++ 830A 28 16            JR Z, move_down ; Han pulsado ENTER -> Mover abajo
 13++ 830C 18 1E            JR no_tecla_move     ; No hay tecla pulsada
 14++ 830E
 15++ 830E              move_right:
 16++ 830E 3A 59 82         LD A, (Middle)
 17++ 8311 3C               INC A
 18++ 8312 32 59 82         LD (Middle), A
 19++ 8315 18 0E            JR SoltarTeclaMv     ; Esperar que suelten la tecla
 20++ 8317 C9               RET
 21++ 8318
 22++ 8318              move_left:
 23++ 8318 3A 59 82         LD A, (Middle)
 24++ 831B 3D               DEC A
 25++ 831C 32 59 82         LD (Middle), A
 26++ 831F 18 04            JR SoltarTeclaMv     ; Esperar que suelten la tecla
 27++ 8321 C9               RET
 28++ 8322
 29++ 8322              move_down:
 30++ 8322 FD 23            INC IY ;Se baja la fila
 31++ 8324 C9               RET ;Se sale de la rutina
 32++ 8325
 33++ 8325              SoltarTeclaMv:           ; Rutina de espera hasta que se suelta la tecla
 34++ 8325 ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 35++ 8327 FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 36++ 8329 20 FA            JR NZ,SoltarTeclaMv  ; esperar hasta que no haya tecla pulsada
 37++ 832B C9               RET
 38++ 832C
 39++ 832C              no_tecla_move:
 40++ 832C C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\tetro-move.asm
 24+  832D                  INCLUDE del-row.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-row.asm
  1++ 832D              DELROW: ;Esta subrutina es igual que la del borde, solo que se comprueba si existe una fila en la que sea todo color.
  2++ 832D              ANCHOTAB EQU 14
  3++ 832D              LARGOTAB EQU 17
  4++ 832D              ;-----------------------------------------------------------------------------------------------------------------------------
  5++ 832D 3E 20            LD A, 32
  6++ 832F D6 02            SUB 2
  7++ 8331 D6 0E            SUB ANCHOTAB
  8++ 8333 CB 3F            SRL A
  9++ 8335 4F               LD C, A
 10++ 8336 3E 00            LD A, 0
 11++ 8338 C6 9F            ADD (32 * 5 - 1)
 12++ 833A 47               LD B, A
 13++ 833B 21 00 58         LD HL, $5800
 14++ 833E              buc1:
 15++ 833E 23               INC HL
 16++ 833F 10 FD            DJNZ buc1
 17++ 8341 06 11            LD B, LARGOTAB
 18++ 8343              buc:
 19++ 8343 C5               PUSH BC
 20++ 8344 41               LD B, C
 21++ 8345              marco_izquierdo:
 22++ 8345 23               INC HL
 23++ 8346 10 FD            DJNZ marco_izquierdo
 24++ 8348 C5               PUSH BC
 25++ 8349              margen__izq:
 26++ 8349 23               INC HL
 27++ 834A
 28++ 834A
 29++ 834A 06 0E            LD B, ANCHOTAB
 30++ 834C 3E 00            LD A, 0
 31++ 834E 32 5A 82         LD (FilaCompleta), A ;FilaCompleta será un contador. Si el contador llega a ser igual que el ancho, significará que se ha encontrado una fila completa de color
 32++ 8351              comienzo__ancho:
 33++ 8351 23               INC HL
 34++ 8352 7E               LD A, (HL)
 35++ 8353 FE 00            CP 0
 36++ 8355 20 07            JR NZ, color
 37++ 8357 28 00            JR Z, reinicio_color
 38++ 8359              reinicio_color:
 39++ 8359 3E 00            LD A, 0 ;Si no se detecta color, inicializamos FilaCompleta a 0, por lo que ya nunca llegará a valer lo que vale anchotab
 40++ 835B 32 5A 82         LD (FilaCompleta), A
 41++ 835E              color:
 42++ 835E 3A 5A 82         LD A, (FilaCompleta)
 43++ 8361 3C               INC A ;Si se detecta color, incrementamos FilaCompleta
 44++ 8362 32 5A 82         LD (FilaCompleta), A
 45++ 8365 10 EA            DJNZ comienzo__ancho
 46++ 8367
 47++ 8367 3A 5A 82         LD A, (FilaCompleta)
 48++ 836A FE 0E            CP ANCHOTAB ;Comparamos con ANCHOTAB, lo que decidirá si se ha de borrar o no la fila
 49++ 836C 28 02            JR Z, borrarlafila
 50++ 836E 18 0B            JR cotinuerowdel
 51++ 8370              borrarlafila:
 52++ 8370 3E 00            LD A, 0
 53++ 8372 06 0E            LD B, ANCHOTAB
 54++ 8374 80               ADD B
 55++ 8375 47               LD B, A ;Creamos un bucle a la inversa, que decremente HL una fila y ponga a negro dicha fila pixel a pixel.
 56++ 8376              decrementarhl:
 57++ 8376 36 00            LD (HL), 0
 58++ 8378 2B               DEC HL
 59++ 8379 10 FB            DJNZ decrementarhl
 60++ 837B              cotinuerowdel:
 61++ 837B              margen__drcho:
 62++ 837B 23               INC HL
 63++ 837C
 64++ 837C C1               POP BC
 65++ 837D 41               LD B, C
 66++ 837E              marco_derecho
 67++ 837E 23               INC HL
 68++ 837F 10 FD            DJNZ marco_derecho
 69++ 8381 C1               POP BC
 70++ 8382 10 BF            DJNZ buc
 71++ 8384
 72++ 8384 C9               RET
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\del-row.asm
 25+  8385
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\game.asm
 19   8385                  INCLUDE pantalla-inicio.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-inicio.asm
  1+  8385
  2+  8385              STARTSCREEN:                                   ;
  3+  8385 CD 99 84         CALL CLEARSCR                              ;
  4+  8388 CD 8B 83         CALL startInit                             ;
  5+  838B              ;Muestra la pantalla de inicio del juego       ;
  6+  838B              ;-----------------------------------------------
  7+  838B              startInit:
  8+  838B              ;Imprimir título
  9+  838B 3E 83            LD A,3+$80 ; Se da formato de color al texto
 10+  838D 06 03            LD B,3     ; Coordenada de la fila
 11+  838F 0E 08            LD C,8     ; Coordenada de la columna
 12+  8391 DD 21 EA 83      LD IX,StartTitle    ; Se añade el título
 13+  8395 CD 28 84         CALL PRINTAT    ; Se llama a la rutina que imprime el título
 14+  8398
 15+  8398              ;Imprimir pregunta
 16+  8398
 17+  8398 3E 04            LD A,4  ; Se da formato de color al texto
 18+  839A 06 0E            LD B,14 ; Coordenada de la fila
 19+  839C 0E 02            LD C,2  ; Coordenada de la columna
 20+  839E DD 21 FC 83      LD IX,StartQuestion ; Se añade la pregunta
 21+  83A2 CD 28 84         CALL PRINTAT ; Se llama a la rutina para imprimir la pregunta
 22+  83A5
 23+  83A5 06 0E            LD B,14 ; Se pone el cursor en las coordenadas 14(fila)
 24+  83A7 0E 1C            LD C,28 ; y 28(Columna)
 25+  83A9 CD B2 83         CALL Coor_Atrib ; Llamamos a la rutina encargada de devolver la dirección del atributo
 26+  83AC 3E 84            LD A,4+$80  ; Se le da el formato
 27+  83AE 77               LD (HL),A   ; Se imprime el cursor
 28+  83AF
 29+  83AF CD CD 83         CALL TecladoInicio    ; Se lee el input del teclado hasta que se pulse S o N
 30+  83B2
 31+  83B2
 32+  83B2              ;Función para guardar coordenadas
 33+  83B2              Coor_Atrib:
 34+  83B2 F5               PUSH AF ; Se guarda el registro AF en el stack
 35+  83B3 60               LD H,b  ; Los bits 4,5 de B deben ser los bits 0,1 de H
 36+  83B4 CB 3C            SRL H
 36+  83B6 CB 3C          SRL H
 36+  83B8 CB 3C          SRL H
 37+  83BA 78               LD A,B  ; Los bits 0,1,2 de B deben ser los bits 5,6,7 de L
 38+  83BB CB 27            SLA A
 38+  83BD CB 27          SLA A
 38+  83BF CB 27          SLA A
 38+  83C1 CB 27          SLA A
 38+  83C3 CB 27          SLA a
 39+  83C5 B1               OR c  ; Y C son los bits 0-4 de L
 40+  83C6 6F               LD L,A
 41+  83C7 01 00 58         LD BC, $5800
 42+  83CA 09               ADD HL,BC ; Se le suma la dirección de memoria del comienzo de los atributos
 43+  83CB F1               POP AF ; Se devuelve el registro AF del stack
 44+  83CC C9               RET
 45+  83CD
 46+  83CD              ;Rutina que guarda lo que pulsa el usuario
 47+  83CD              TecladoInicio:          ; Rutina para leer del teclado 'S' o 'N'
 48+  83CD 01 FE 7F         LD BC,$7FFE         ; Escanear línea B,N,M,SYMB,Space
 49+  83D0 ED 78            IN A,(C)
 50+  83D2 CB 5F            BIT 3,A
 51+  83D4 28 0C            JR Z,T_N            ; Han pulsado N
 52+  83D6 01 FE FD         LD BC,$FDFE         ; Escanear línea G,F,D,S,A
 53+  83D9 ED 78            IN A,(C)
 54+  83DB CB 4F            BIT 1,A
 55+  83DD 20 EE            JR NZ,TecladoInicio       ; No han pulsado 'S'
 56+  83DF
 57+  83DF              T_S:
 58+  83DF 18 02            JR Soltar_Tecla     ; Esperar q que suelten la tecla
 59+  83E1 C9               RET
 60+  83E2
 61+  83E2              T_N:
 62+  83E2 C9               RET
 63+  83E3
 64+  83E3              Soltar_Tecla:           ; Rutina de espera hasta que se suelta la tecla
 65+  83E3 ED 78            IN A,(C)            ; Leer del puerto que se ha definido en Lee_Tecla
 66+  83E5 FE FF            CP $FF              ; Comprobar que no hay tecla pulsada
 67+  83E7 20 FA            JR NZ,Soltar_Tecla  ; esperar hasta que no haya tecla pulsada
 68+  83E9 C9               RET
 69+  83EA
 70+  83EA              ;----------------------------------------------------------------------------
 71+  83EA              ; Carga de ficheros y "variables"
 72+  83EA 57 45 4C 43  StartTitle: db "WELCOME TO TETRIS", 0 ;Título del tetris
 72+  83EE 4F 4D 45 20
 72+  83F2 54 4F 20 54
 72+  83F6 45 54 52 49
 72+  83FA 53 00
 73+  83FC 49 6E 69 63  StartQuestion: db "Iniciar una partida? (S/N)", 0 ;Pregunta Inicio
 73+  8400 69 61 72 20
 73+  8404 75 6E 61 20
 73+  8408 70 61 72 74
 73+  840C 69 64 61 3F
 73+  8410 20 28 53 2F
 73+  8414 4E 29 00
 74+  8417 48 61 73 20  Respuesta: db "Has contestado: ",0  ; Mensaje con la respuesta
 74+  841B 63 6F 6E 74
 74+  841F 65 73 74 61
 74+  8423 64 6F 3A 20
 74+  8427 00
 75+  8428
 76+  8428
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\pantalla-inicio.asm
 20   8428                  INCLUDE printat.asm ;Se "importa" la rutina printat
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\printat.asm
  1+  8428              ; -------------------------------
  2+  8428              ; ZX Spectrum Text print library
  3+  8428              ; Daniel León - AOC - UFV 2020
  4+  8428              ; -------------------------------
  5+  8428
  6+  8428
  7+  8428              ; ----------------------------------------------------------------------------------------
  8+  8428              ; PRINTAT - Print a string in a position and attributes as per registers:
  9+  8428              ;		IN	A	: Bit 7=1 For Flash / Bit 6=1 For Brigh / Bit 5,4,3 for Paper / Bit 2,1,0 for Ink
 10+  8428              ;		IN	B	: Row 0..23
 11+  8428              ;		IN	C	: Column 0..31
 12+  8428              ;		IN	IX	: Address of text (Text must end in a 0)
 13+  8428              ; ----------------------------------------------------------------------------------------
 14+  8428 CD 37 84     PRINTAT:	CALL PREP_PRT				; Update Attribute var &Screen & Attributes pointers
 15+  842B              ; ----------------------------------------------------------------------------------------
 16+  842B              ;		VVV Do not move PRINTSTR below as PRINTAT continues into PRINTSTR routine
 17+  842B              ; ----------------------------------------------------------------------------------------
 18+  842B              ; PRINTSTR - Prints String - IX Points to the String start
 19+  842B              ; ----------------------------------------------------------------------------------------
 20+  842B DD 7E 00     PRINTSTR:   LD A,(IX)					; A Contains first char to print
 21+  842E B7           			OR A						; check for end of string (0)
 22+  842F C8           			RET Z						; Finish printing if 0
 23+  8430 CD 65 84     			CALL PRINTCHNUM
 24+  8433 DD 23        			INC IX						; Move to next char in string
 25+  8435 18 F4        			JR PRINTSTR					; Start over printing sequence
 26+  8437              ; ----------------------------------------------------------------------------------------
 27+  8437
 28+  8437
 29+  8437              ;-----------------------------------------------------------------------------------------
 30+  8437              ; PREP_PRT - Updates Print_Attr, SCR & ATTR Vars
 31+  8437              ;-----------------------------------------------------------------------------------------
 32+  8437 32 AB 84     PREP_PRT:	LD (PRINT_ATTR),A			; Set Attribute
 33+  843A CD 40 84     PREP_PRT_2:	CALL CRtoSCREEN
 34+  843D C3 52 84     			JP CRtoATTR
 35+  8440              ;-----------------------------------------------------------------------------------------
 36+  8440
 37+  8440              ;-----------------------------------------------------------------------------------------
 38+  8440              ; CRtoSCREEN - Converts a scr char coord into a SCREEN Address   b,c = y,x positions
 39+  8440              ;	IN  - B=Row, C=Column
 40+  8440              ;	OUT - HL=Address in screen also stored in (SCR_CUR_PTR)
 41+  8440              ;	Conversion:
 42+  8440              ;			Row FFfff   Column CCCCC
 43+  8440              ;			HL=%010FF000 fffCCCCC
 44+  8440              ;-----------------------------------------------------------------------------------------
 45+  8440              CRtoSCREEN:
 46+  8440 78           			LD A,B						; %___FFfff
 47+  8441 F6 40        			OR #40						; %010FFfff
 48+  8443 E6 F8        			AND #F8						; %010FF000
 49+  8445 67           			LD H,A
 50+  8446
 51+  8446 78           			LD A,B						; %___FFfff
 52+  8447 E6 07        			AND #7						; %00000fff
 53+  8449 0F           			RRCA						; %f00000ff
 54+  844A 0F           			RRCA						; %ff00000f
 55+  844B 0F           			RRCA						; %fff00000
 56+  844C B1           			OR C						; %fffCCCCC
 57+  844D 6F           			LD L,A
 58+  844E 22 A7 84                 LD (SCR_CUR_PTR),HL			; Update Variable
 59+  8451 C9                       RET
 60+  8452              ; ----------------------------------------------------------------------------------------
 61+  8452
 62+  8452
 63+  8452
 64+  8452              ;-----------------------------------------------------------------------------------------
 65+  8452              ; CRtoATTR - Converts a screen char coord  into a ATTR Address  b,c = y,x positions
 66+  8452              ;	IN  - B=Row, C=Column
 67+  8452              ;	OUT - HL=Address in screen also stored in (SCR_ATTR_PTR)
 68+  8452              ;	Conversion:
 69+  8452              ;			Row FFfff   Column CCCCC
 70+  8452              ;			HL=%010110FF fffCCCCC
 71+  8452              ;-----------------------------------------------------------------------------------------
 72+  8452              CRtoATTR:
 73+  8452 78           			LD A,B						; %___FFfff
 74+  8453 0F           			RRCA						; %f000FFff
 75+  8454 0F           			RRCA						; %ff000FFf
 76+  8455 0F           			RRCA						; %fff000FF
 77+  8456 6F           			LD L,A
 78+  8457 E6 03        			AND 3						; %000000FF	value of FF can be only 00,01,10
 79+  8459 F6 58        			OR #58						; %010110FF value will be #58, #59 or #5A
 80+  845B 67           			LD H,A
 81+  845C
 82+  845C 7D           			LD A,L						; %fff000FF
 83+  845D E6 E0        			AND #E0						; %fff00000
 84+  845F B1           			OR C						; %fffCCCCC
 85+  8460 6F           			LD L,A
 86+  8461
 87+  8461 22 A9 84                 LD (SCR_ATTR_PTR),HL		; Update Variable
 88+  8464 C9                       RET
 89+  8465              ; ----------------------------------------------------------------------------------------
 90+  8465
 91+  8465
 92+  8465
 93+  8465              ; ----------------------------------------------------------------------------------------
 94+  8465              ; PRINTCHNUM - Prints Char Number N (stored in A)
 95+  8465              ;-----------------------------------------------------------------------------------------
 96+  8465              PRINTCHNUM:	;SUB 32						; Adjust Ascii to charset
 97+  8465 26 00        			LD H,0						; Multiply value by 8 to get to right Char in Charset
 98+  8467 6F           			LD L,A
 99+  8468 29           			ADD HL,HL
100+  8469 29           			ADD HL,HL
101+  846A 29           			ADD HL,HL
102+  846B 11 AC 83     			LD DE, CHARSET-(8*32)		; Optimize in compile time (instead of sub 32)
103+  846E 19           			ADD HL,DE
104+  846F EB           			EX  DE,HL					;Value in DE
105+  8470              			; Continues to printchar below
106+  8470              ; ----------------------------------------------------------------------------------------
107+  8470
108+  8470
109+  8470              ; ----------------------------------------------------------------------------------------
110+  8470              ; PRINTCHAR - Prints Char  (DE points to the char. Uses HL as last Cur Pointer)
111+  8470              ; ----------------------------------------------------------------------------------------
112+  8470              PRINTCHAR:
113+  8470 06 08        			LD B,8						; 8 Lines per char
114+  8472 2A A7 84                 LD HL, (SCR_CUR_PTR)		; Load Cursor Pointer y,x
115+  8475
116+  8475 1A           BYTEPCHAR:	LD A,(DE)					; Get Char to be printed, first line
117+  8476 77           			LD (HL),A					; Move to Printing location
118+  8477 24                       INC H						; inc H so next line in char (ZX Spectrum Screen RAM)
119+  8478 13                       INC DE 						; next line to be printed
120+  8479 10 FA                    DJNZ BYTEPCHAR				; Repeat 8 lines
121+  847B 3A AB 84                 LD A,(PRINT_ATTR) 			; Load Attributes to print char with
122+  847E 2A A9 84                 LD HL, (SCR_ATTR_PTR)
123+  8481 77                       LD (HL),A
124+  8482 21 A9 84                 LD HL, SCR_ATTR_PTR			; Get pointer to ATTR
125+  8485 34                       INC (HL)					; Move Attribute cursor to next char
126+  8486 21 A7 84     			LD HL, SCR_CUR_PTR
127+  8489 34           			INC (HL)					; update Cursor pointer to next position
128+  848A C9                       RET
129+  848B              ; ----------------------------------------------------------------------------------------
130+  848B
131+  848B
132+  848B
133+  848B              ; ----------------------------------------------------------------------------------------
134+  848B              ; INK2PAPER - moves ink of attribute stored in (PRINT_ATTR) to paper and sets ink to 0
135+  848B              ; 				Sets bright 1 and flash 0
136+  848B              ; ----------------------------------------------------------------------------------------
137+  848B 3A AB 84     INK2PAPER:	LD A, (PRINT_ATTR)		    ; Get storedAttribute
138+  848E E6 07                    AND 7						; get Attr INK in A
139+  8490 07           			RLCA
140+  8491 07           			RLCA
141+  8492 07           			RLCA						; move Ink to Paper
142+  8493 F6 40        			OR 64						; ink 0 bright 1
143+  8495 32 AB 84     			LD (PRINT_ATTR),A		    ; Get storedAttribute
144+  8498 C9           			RET
145+  8499              ; ----------------------------------------------------------------------------------------
146+  8499
147+  8499
148+  8499
149+  8499
150+  8499 21 00 40     CLEARSCR:	LD HL,$4000					; Erases screen by writing 0 to all pixels and attributes
151+  849C 11 01 40     			LD DE,$4001
152+  849F 01 FF 1A     			LD BC,6911
153+  84A2 36 00        			LD (HL),0
154+  84A4 ED B0        			LDIR
155+  84A6 C9           			RET
156+  84A7
157+  84A7
158+  84A7              SCR_CUR_PTR
158+  84A7 00 00          	db $00, $00				; Cursor Pointer in Screen (2 bytes) (HL)
159+  84A9 00 00        SCR_ATTR_PTR: 	db $00, $00				; Attr Pointer in Screen (2 bytes) (HL)
160+  84AB 00           PRINT_ATTR:		db $00					; Attribute used by printchar routine (1 byte)
161+  84AC
162+  84AC              CHARSET: incbin "charset.bin"			; Charset used
163+  87AC
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\printat.asm
 21   87AC                  INCLUDE fichas.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\fichas.asm
  1+  87AC              TETROMINOS:                                                       ;
  2+  87AC              ;Rutina que contiene la forma de los tetrominos, y sus rotaciones ;
  3+  87AC              ;-----------------------------------------------------------------;
  4+  87AC              ;Tetromino O
  5+  87AC 02 02 30 30  T_O: DB 2, 2, 6*8, 6*8, 6*8, 6*8, 0, 0
  5+  87B0 30 30 00 00
  5+  87B4 AC 87 AC 87    DW T_O, T_O
  6+  87B8              ;Tetromino L
  7+  87B8 03 02 20 00  T_L1: DB 3, 2, 4*8, 0, 4*8, 0, 4*8, 4*8
  7+  87BC 20 00 20 20
  7+  87C0 C4 87 D0 87    DW T_L2, T_L3
  8+  87C4 02 03 00 00  T_L2: DB 2, 3, 0, 0, 4*8, 4*8, 4*8, 4*8
  8+  87C8 20 20 20 20
  8+  87CC DC 87 B8 87    DW T_L4, T_L1
  9+  87D0 02 03 20 20  T_L3: DB 2, 3, 4*8, 4*8, 4*8, 4*8, 0, 0
  9+  87D4 20 20 00 00
  9+  87D8 B8 87 DC 87    DW T_L1, T_L4
 10+  87DC 03 02 20 20  T_L4: DB 3, 2, 4*8, 4*8, 0, 4*8, 0, 4*8
 10+  87E0 00 20 00 20
 10+  87E4 D0 87 C4 87    DW T_L3, T_L2
 11+  87E8              ;Tetromino J
 12+  87E8 03 02 00 10  T_J1: DB 3, 2, 0, 2*8, 0, 2*8, 2*8, 2*8
 12+  87EC 00 10 10 10
 12+  87F0 F4 87 00 88    DW T_J2, T_J3
 13+  87F4 02 03 10 10  T_J2: DB 2, 3, 2*8, 2*8, 2*8, 0, 0, 2*8
 13+  87F8 10 00 00 10
 13+  87FC 0C 88 E8 87    DW T_J4, T_J1
 14+  8800 02 03 10 00  T_J3: DB 2, 3, 2*8, 0, 0, 2*8, 2*8, 2*8
 14+  8804 00 10 10 10
 14+  8808 E8 87 0C 88    DW T_J1, T_J4
 15+  880C 03 02 10 10  T_J4: DB 3, 2, 2*8, 2*8, 2*8, 0, 2*8, 0
 15+  8810 10 00 10 00
 15+  8814 00 88 F4 87    DW T_J3, T_J2
 16+  8818              ;Tetromino T
 17+  8818 02 03 28 28  T_T1: DB 2, 3, 5*8, 5*8, 5*8, 0, 5*8, 0
 17+  881C 28 00 28 00
 17+  8820 24 88 30 88    DW T_T2, T_T3
 18+  8824 03 02 28 00  T_T2: DB 3, 2, 5*8, 0, 5*8, 5*8, 5*8, 0
 18+  8828 28 28 28 00
 18+  882C 3C 88 18 88    DW T_T4, T_T1
 19+  8830 03 02 00 28  T_T3: DB 3, 2, 0, 5*8, 5*8, 5*8, 0, 5*8
 19+  8834 28 28 00 28
 19+  8838 18 88 3C 88    DW T_T1, T_T4
 20+  883C 02 03 00 28  T_T4: DB 2, 3, 0, 5*8, 0, 5*8, 5*8, 5*8
 20+  8840 00 28 28 28
 20+  8844 30 88 24 88    DW T_T3, T_T2
 21+  8848              ;Tetromino I
 22+  8848 04 01 30 30  T_I1: DB 4, 1, 6*8, 6*8, 6*8, 6*8, 0, 0
 22+  884C 30 30 00 00
 22+  8850 54 88 54 88    DW T_I2, T_I2
 23+  8854 01 04 30 30  T_I2: DB 1, 4, 6*8, 6*8, 6*8, 6*8, 0, 0
 23+  8858 30 30 00 00
 23+  885C 48 88 48 88    DW T_I1, T_I1
 24+  8860              ;Tetromino Z
 25+  8860 02 03 38 38  T_Z1: DB 2, 3, 7*8, 7*8, 0, 0, 7*8, 7*8
 25+  8864 00 00 38 38
 25+  8868 6C 88 6C 88    DW T_Z2, T_Z2
 26+  886C 03 02 00 38  T_Z2: DB 3, 2, 0, 7*8, 7*8, 7*8, 7*8, 0
 26+  8870 38 38 38 00
 26+  8874 60 88 60 88    DW T_Z1, T_Z1
 27+  8878              ;Tetromino S
 28+  8878 02 03 00 18  T_S1: DB 2, 3, 0, 3*8, 3*8, 3*8, 3*8, 0
 28+  887C 18 18 18 00
 28+  8880 84 88 84 88    DW T_S2, T_S2
 29+  8884 03 02 18 00  T_S2: DB 3, 2, 3*8, 0, 3*8, 3*8, 0, 3*8
 29+  8888 18 18 00 18
 29+  888C 78 88 78 88    DW T_S1, T_S1
 30+  8890
 31+  8890 00 01 02 03  row_coords: DB 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
 31+  8894 04 05 06 07
 31+  8898 08 09 0A 0B
 31+  889C 0C 0D 0E 0F
 31+  88A0 10 11 12 13
 31+  88A4 14 15 16
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\fichas.asm
 22   88A7                  INCLUDE Tetris_3D.asm
# file opened: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\Tetris_3D.asm
  1+  88A7 FF 81 81 85  Tetro_3D:   DB $FF, $81, $81, $85, $85, $9D, $81, $FF ; Patrón para los bloques
  1+  88AB 85 9D 81 FF
  2+  88AF
  3+  88AF              Tetris_3D:
  4+  88AF 16 03            LD D,3              ; Los 3 bloques de píxeles
  5+  88B1 DD 21 00 40      LD IX,$4000         ; Dirección de comienzo de la VRAM
  6+  88B5
  7+  88B5              T3D3:
  8+  88B5
  9+  88B5 FD 21 A7 88      LD IY,Tetro_3D      ; Primer byte del patrón
 10+  88B9
 11+  88B9 0E 08            LD C,8              ; 8 bytes del patrón
 12+  88BB              T3D2:
 13+  88BB 06 00            LD B,0              ; 256 bytes de cada línea del patrón
 14+  88BD FD 7E 00         LD a,(IY)           ; Cargo el valor del patrón
 15+  88C0              T3D1:
 16+  88C0 DD 77 00         LD (IX),a           ; Cargo el patrón en la VideoRam
 17+  88C3 DD 23            INC IX              ; Siguientes 8 pixels
 18+  88C5 10 F9            DJNZ T3D1           ; Fin del bucle
 19+  88C7
 20+  88C7 0D               DEC C               ; Fin del 2º Bucle
 21+  88C8 FD 23            inc IY              ; Siguiente byte del patrón
 22+  88CA 20 EF            JR NZ,T3D2
 23+  88CC
 24+  88CC 15               DEC D               ; Fin del 3º bucle
 25+  88CD 20 E6            JR NZ, T3D3
 26+  88CF
 27+  88CF C9               RET
 28+  88D0
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\Tetris_3D.asm
# file closed: C:\Users\PC GAMING\Documents\Trabajos Uni\2º\Arquitectura\Tetris\main.asm
